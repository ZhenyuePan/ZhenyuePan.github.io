---
title: "daily note"
publishedAt: "2024-08-23"
summary: "Tanks for watching."
---
#  é—®é¢˜æ—¥å¿—

# 2024

> Operating System: A body of software, in fact, that is responsible for making it easy to run programs (even allowing you to seemingly run many at the same time), allowing programs to share memory, enabling programs to interact with devices, and other fun stuff like that. (OSTEP)

***

# todo list

9.14

- [x] å®ªæ³•
- [ ] è®ºæ–‡å†™ä½œmooc
- [x] ~~æ•°æ®åº“~~æ•°æ®åº“ä¹‹é—´çš„å¼‚åŒï¼Œç®—ç´¢å¼•
- [x] ~~å…¥å…šç”³è¯·ä¹¦~~
- [x] è½®æ»‘
- [x] å‚ä¿
- [ ] å­¦ç”Ÿè¯
- [x] æ™ºæ…§å›¢å»º
- [ ] ~~ç ”ç©¶ç”Ÿä¼šç«é€‰~~
- [x] æ•°æ®åº“ä½œä¸š
- [ ] ç»„åˆæ•°å­¦ä½œä¸š
- [ ] 1.ä»»é€‰æ–°å‹æ•°æ®åº“ï¼Œå‚è€ƒä¸€ç³»åˆ—æ–‡çŒ®
- [ ] 2.ppt å†…å®¹ï¼šæ•°æ®åº“åŸºæœ¬ç‰¹å¾
- [ ] å“ªäº›åŸºæœ¬æ¦‚å¿µ
- [ ] ä½“æ£€é¢„çº¦

***

### æ—¥å¸¸æ‰“å¡

CS106L(C++),CS106B/X(C++é¢å‘å¯¹è±¡),CS144(è®¡ç®—æœºç½‘ç»œ),15-213(CSAPP),6.S081(OS),jyyOS,njuPA,6.824ï¼ˆåˆ†å¸ƒå¼ç³»ç»Ÿï¼‰ï¼Œ15-445ï¼ˆæ•°æ®åº“ç³»ç»Ÿ)

------

### å…«æœˆæ€»ç»“ 9.18

8æœˆ23æ—¥å¼€å­¦

ä¸‰ä¸ªæ˜ŸæœŸå¤šå››å¤©ï¼Œå­¦ä¹ äº†vimï¼Œgitï¼Œcmake

æ“ä½œç³»ç»Ÿçœ‹äº†ä¸€åŠ

æ•°æ®åº“çœ‹äº†ä¸€ç‚¹ç‚¹

å­¦ä¹ äº†åŠ¨æ€è§„åˆ’ç®—æ³•

----

### ä¹æœˆæ€»ç»“ 9.30

lc åˆ·äº†å…­ä¸ªé¢˜

æ“ä½œç³»ç»Ÿå¹¶è¡Œçœ‹å®Œäº†

å­¦ä¹ äº†gitï¼Œshellå‘½ä»¤è¡Œçš„ç”¨æ³•

é…ç½®å¥½äº†ç¯å¢ƒ

åˆ¶å®šå¥½äº†å¯’å‡çš„ä¸€ä¸ªå°è¯•å®ä¹ çš„è®¡åˆ’

### â™¥æœŸæœ«è€ƒè¯•æ—¶é—´æ•´ç†

æ•°æ®åº“ï¼šç¬¬13å‘¨å‘¨äºŒæ™šä¸Š6ç‚¹30è‡³8ç‚¹30

åœ°ç‚¹è¯šæ„107ï¼ˆ11.19ï¼Œ21ï¼‰

 ç»„åˆæ•°å­¦ï¼š

### å…³äºä¸€äº›å·¥å…·é“¾andæŠ€æœ¯æ ˆ

1.vim,gitï¼Œshellï¼Œlinuxï¼Œgccç¼–è¯‘

æœªå­¦:**gdbï¼Œcmakeï¼ŒmakefileğŸ•,mysql**

**redis,kafka,nginx**

### ä¸€ä¸ªwindowsæ¡Œé¢åº”ç”¨

ç”¨ C++ å®Œå…¨å¯ä»¥å¼€å‘ä¸€ä¸ªé›†æˆè¯¾ç¨‹è¡¨ã€æ¯æ—¥æ‰“å¡ã€ç•ªèŒ„æ—¶é’ŸåŠŸèƒ½çš„æ¡Œé¢åº”ç”¨ã€‚ä»¥ä¸‹æ˜¯ç›¸å…³çš„çŸ¥è¯†å’ŒæŠ€æœ¯ç‚¹ï¼š

#### ä¸€ã€ç”¨æˆ·ç•Œé¢

1. Windows APIï¼ˆé€‚ç”¨äº Windows å¹³å°ï¼‰
   - æ¦‚è¿°
     - Windows APIï¼ˆApplication Programming Interfaceï¼‰æä¾›äº†åˆ›å»º Windows æ¡Œé¢åº”ç”¨æ‰€éœ€çš„å„ç§å‡½æ•°ã€‚å¯ä»¥ç›´æ¥è°ƒç”¨è¿™äº›å‡½æ•°æ¥åˆ›å»ºçª—å£ã€æŒ‰é’®ã€æ–‡æœ¬æ¡†ç­‰å„ç§ç•Œé¢å…ƒç´ ã€‚
   - éœ€è¦å­¦ä¹ çš„å†…å®¹
     - çª—å£åˆ›å»ºä¸ç®¡ç†ï¼šå­¦ä¹ å¦‚ä½•ä½¿ç”¨`CreateWindowEx`å‡½æ•°åˆ›å»ºçª—å£ï¼Œè®¾ç½®çª—å£çš„æ ·å¼ã€å¤§å°å’Œä½ç½®ï¼Œä»¥åŠå¦‚ä½•å¤„ç†çª—å£æ¶ˆæ¯ï¼ˆå¦‚`WM_CREATE`ã€`WM_PAINT`ã€`WM_DESTROY`ç­‰æ¶ˆæ¯ï¼‰ã€‚
     - æ§ä»¶åˆ›å»ºï¼šæŒæ¡ä½¿ç”¨ Windows API åˆ›å»ºå¸¸è§æ§ä»¶ï¼Œå¦‚`CreateButton`å‡½æ•°åˆ›å»ºæŒ‰é’®ï¼Œ`CreateEdit`å‡½æ•°åˆ›å»ºæ–‡æœ¬ç¼–è¾‘æ¡†ç­‰ã€‚
     - æ¶ˆæ¯å¾ªç¯ï¼šç†è§£å¹¶å®ç°æ¶ˆæ¯å¾ªç¯æœºåˆ¶ï¼Œé€šè¿‡`GetMessage`ã€`TranslateMessage`å’Œ`DispatchMessage`å‡½æ•°æ¥å¤„ç†ç”¨æˆ·è¾“å…¥å’Œç³»ç»Ÿæ¶ˆæ¯ã€‚
2. Qt æ¡†æ¶
   - æ¦‚è¿°
     - Qt æ˜¯ä¸€ä¸ªè·¨å¹³å°çš„ C++ å›¾å½¢ç”¨æˆ·ç•Œé¢ï¼ˆGUIï¼‰æ¡†æ¶ï¼Œå¯ç”¨äºå¼€å‘åœ¨ Windowsã€Linuxã€macOS ç­‰å¤šä¸ªå¹³å°ä¸Šè¿è¡Œçš„æ¡Œé¢åº”ç”¨ã€‚
   - éœ€è¦å­¦ä¹ çš„å†…å®¹
     - Qt åŸºç¡€ï¼šå­¦ä¹  Qt çš„åŸºæœ¬æ¦‚å¿µï¼Œå¦‚ä¿¡å·ä¸æ§½æœºåˆ¶ï¼ˆç”¨äºå¯¹è±¡é—´çš„é€šä¿¡ï¼‰ã€å¸ƒå±€ç®¡ç†ï¼ˆå¦‚`QVBoxLayout`ã€`QHBoxLayout`ç­‰å¸ƒå±€ç±»ï¼‰ã€äº‹ä»¶å¤„ç†ç­‰ã€‚
     - æ§ä»¶ä½¿ç”¨ï¼šæŒæ¡ Qt ä¸­çš„å„ç§æ§ä»¶ï¼Œå¦‚`QPushButton`ï¼ˆæŒ‰é’®ï¼‰ã€`QTableWidget`ï¼ˆå¯ç”¨äºè¯¾ç¨‹è¡¨æ˜¾ç¤ºï¼‰ã€`QTimer`ï¼ˆå¯ç”¨äºç•ªèŒ„æ—¶é’Ÿè®¡æ—¶ï¼‰ç­‰çš„ä½¿ç”¨æ–¹æ³•ã€‚
     - è·¨å¹³å°å¼€å‘ï¼šå¦‚æœæœ‰è·¨å¹³å°éœ€æ±‚ï¼Œè¦å­¦ä¹ å¦‚ä½•ä½¿ç”¨ Qt è¿›è¡Œè·¨å¹³å°ç¼–è¯‘å’Œéƒ¨ç½²ï¼Œç¡®ä¿åº”ç”¨åœ¨ä¸åŒæ“ä½œç³»ç»Ÿä¸Šçš„å…¼å®¹æ€§ã€‚

#### äºŒã€æ•°æ®å¤„ç†

1. è¯¾ç¨‹è¡¨æ•°æ®ç»“æ„
   - å¯ä»¥ä½¿ç”¨`vector`ã€`map`ç­‰æ ‡å‡†æ¨¡æ¿åº“ï¼ˆSTLï¼‰å®¹å™¨æ¥å­˜å‚¨è¯¾ç¨‹è¡¨æ•°æ®ã€‚ä¾‹å¦‚ï¼Œä½¿ç”¨`vector<vector<string>>`æ¥è¡¨ç¤ºè¯¾ç¨‹è¡¨çš„äºŒç»´ç»“æ„ï¼ˆè¡Œä»£è¡¨æ˜ŸæœŸå‡ ï¼Œåˆ—ä»£è¡¨æ—¶é—´æ®µï¼‰ï¼Œæˆ–è€…ä½¿ç”¨`map`æ¥å»ºç«‹è¯¾ç¨‹åç§°ä¸ä¸Šè¯¾æ—¶é—´ç­‰å±æ€§çš„æ˜ å°„å…³ç³»ã€‚
2. æ‰“å¡æ•°æ®å­˜å‚¨
   - å¯ä»¥ä½¿ç”¨æ–‡ä»¶å­˜å‚¨æ‰“å¡æ•°æ®ã€‚ä¾‹å¦‚ï¼Œä½¿ç”¨`ofstream`å’Œ`ifstream`æ¥è¿›è¡Œæ–‡ä»¶çš„å†™å…¥å’Œè¯»å–æ“ä½œã€‚å¦‚æœéœ€è¦æ›´å¤æ‚çš„æ•°æ®ç®¡ç†ï¼Œä¹Ÿå¯ä»¥è€ƒè™‘ä½¿ç”¨æ•°æ®åº“ï¼Œå¦‚ SQLiteã€‚C++ å¯ä»¥é€šè¿‡ SQLite çš„ C API æ¥ä¸ SQLite æ•°æ®åº“äº¤äº’ï¼Œå®ç°æ•°æ®çš„å­˜å‚¨ã€æŸ¥è¯¢å’Œæ›´æ–°ã€‚
3. ç•ªèŒ„æ—¶é’Ÿçš„è®¡æ—¶é€»è¾‘
   - åˆ©ç”¨`chrono`åº“æ¥å¤„ç†æ—¶é—´ç›¸å…³çš„æ“ä½œã€‚ä¾‹å¦‚ï¼Œä½¿ç”¨`std::chrono::steady_clock`æ¥è·å–é«˜ç²¾åº¦çš„æ—¶é—´ï¼Œé€šè¿‡è®¡ç®—æ—¶é—´å·®æ¥å®ç°ç•ªèŒ„æ—¶é’Ÿçš„è®¡æ—¶åŠŸèƒ½ã€‚åŒæ—¶ï¼Œå¯ä»¥ä½¿ç”¨`std::thread`æˆ–`std::async`æ¥å¤„ç†ä¸è®¡æ—¶ç›¸å…³çš„å¼‚æ­¥æ“ä½œï¼Œä¾‹å¦‚åœ¨è®¡æ—¶è¿‡ç¨‹ä¸­å“åº”ç”¨æˆ·çš„æš‚åœã€ç»§ç»­æ“ä½œã€‚

#### ä¸‰ã€åŠŸèƒ½å®ç°

1. è¯¾ç¨‹è¡¨åŠŸèƒ½
   - æ•°æ®è¯»å–ä¸æ˜¾ç¤ºï¼šä»æ–‡ä»¶æˆ–è€…æ•°æ®åº“ä¸­è¯»å–è¯¾ç¨‹è¡¨æ•°æ®ï¼Œå¹¶åœ¨ç•Œé¢ä¸Šä»¥åˆé€‚çš„æ–¹å¼æ˜¾ç¤ºã€‚å¯ä»¥ä½¿ç”¨å‰é¢æåˆ°çš„ç•Œé¢æ¡†æ¶ä¸­çš„è¡¨æ ¼æ§ä»¶æˆ–è€…è‡ªå®šä¹‰ç»˜å›¾æ¥æ˜¾ç¤ºè¯¾ç¨‹ä¿¡æ¯ã€‚
   - è¯¾ç¨‹è¡¨ç¼–è¾‘ï¼šå®ç°æ·»åŠ ã€åˆ é™¤ã€ä¿®æ”¹è¯¾ç¨‹ç­‰åŠŸèƒ½ã€‚è¿™æ¶‰åŠåˆ°ç•Œé¢äº¤äº’ï¼ˆå¦‚ç‚¹å‡»æŒ‰é’®å¼¹å‡ºç¼–è¾‘çª—å£ï¼‰ä»¥åŠå¯¹æ•°æ®ç»“æ„çš„æ“ä½œï¼ˆå¦‚æ›´æ–°`vector`æˆ–è€…`map`ä¸­çš„æ•°æ®ï¼‰ã€‚
2. æ¯æ—¥æ‰“å¡åŠŸèƒ½
   - æ‰“å¡æ“ä½œï¼šåœ¨ç•Œé¢ä¸Šè®¾ç½®æ‰“å¡æŒ‰é’®ï¼Œå½“ç”¨æˆ·ç‚¹å‡»æ—¶ï¼Œè®°å½•æ‰“å¡æ—¶é—´å¹¶å­˜å‚¨åˆ°æ–‡ä»¶æˆ–è€…æ•°æ®åº“ä¸­ã€‚å¯ä»¥æ ¹æ®æ‰“å¡æ•°æ®ç»Ÿè®¡æ‰“å¡å¤©æ•°ã€è¿ç»­æ‰“å¡å¤©æ•°ç­‰ä¿¡æ¯ï¼Œå¹¶åœ¨ç•Œé¢ä¸Šæ˜¾ç¤ºç›¸å…³ç»Ÿè®¡ç»“æœã€‚
   - æé†’åŠŸèƒ½ï¼šåˆ©ç”¨ç³»ç»Ÿå®šæ—¶å™¨ï¼ˆå¦‚ Windows ä¸‹çš„`SetTimer`å‡½æ•°æˆ–è€… Qt ä¸­çš„`QTimer`ï¼‰æ¥è®¾ç½®æ¯æ—¥æ‰“å¡æé†’ï¼Œå½“åˆ°è¾¾è®¾å®šçš„æ‰“å¡æ—¶é—´æ—¶ï¼Œå¼¹å‡ºæé†’çª—å£æˆ–è€…å‘å‡ºæé†’å£°éŸ³ã€‚
3. ç•ªèŒ„æ—¶é’ŸåŠŸèƒ½
   - è®¡æ—¶ä¸çŠ¶æ€ç®¡ç†ï¼šä½¿ç”¨`chrono`åº“æ¥è¿›è¡Œè®¡æ—¶ï¼Œåœ¨è®¡æ—¶è¿‡ç¨‹ä¸­æ”¹å˜ç•Œé¢ä¸Šçš„æ˜¾ç¤ºçŠ¶æ€ï¼ˆå¦‚å€’è®¡æ—¶æ•°å­—çš„æ›´æ–°ï¼‰ã€‚é€šè¿‡å˜é‡æ¥è®°å½•ç•ªèŒ„æ—¶é’Ÿçš„çŠ¶æ€ï¼ˆå¦‚æ­£åœ¨è®¡æ—¶ã€æš‚åœã€ç»“æŸï¼‰ï¼Œå¹¶æ ¹æ®ç”¨æˆ·æ“ä½œï¼ˆå¦‚ç‚¹å‡»å¼€å§‹ / æš‚åœæŒ‰é’®ï¼‰æ¥åˆ‡æ¢çŠ¶æ€ã€‚
   - ç•ªèŒ„æ—¶æ®µç®¡ç†ï¼šè®¾ç½®ç•ªèŒ„æ—¶é’Ÿçš„å·¥ä½œæ—¶é—´ï¼ˆä¾‹å¦‚ 25 åˆ†é’Ÿï¼‰å’Œä¼‘æ¯æ—¶é—´ï¼ˆä¾‹å¦‚ 5 åˆ†é’Ÿï¼‰ï¼Œå½“ä¸€ä¸ªç•ªèŒ„æ—¶æ®µç»“æŸåï¼Œè‡ªåŠ¨åˆ‡æ¢åˆ°ä¸‹ä¸€ä¸ªæ—¶æ®µï¼Œå¹¶å‘å‡ºç›¸åº”çš„æç¤ºéŸ³æˆ–è€…é€šçŸ¥ã€‚

----

## ç®—æ³•æ•´ç†

### å›æº¯ï¼Œè´ªå¿ƒï¼Œdp

## å¸¸ç”¨APIæ•´ç†

### â¤STLç›¸å…³ï¼š

### `std::vector<T>`

- `push_back(const T& value)`: æ·»åŠ å…ƒç´ è‡³æœ«å°¾
- `pop_back()`: ç§»é™¤æœ«å°¾å…ƒç´ 
- `size()`: è·å–å…ƒç´ æ•°é‡
- `empty()`: æ£€æŸ¥å®¹å™¨æ˜¯å¦ä¸ºç©º
- `clear()`: æ¸…ç©ºå®¹å™¨
- `begin()`, `end()`: è·å–è¿­ä»£å™¨

### `std::list<T>`

- `push_back(const T& value)`, `push_front(const T& value)`: æ·»åŠ å…ƒç´ 
- `pop_back()`, `pop_front()`: ç§»é™¤å…ƒç´ 
- `size()`, `empty()`, `clear()`: åŒ`std::vector`
- `begin()`, `end()`: è·å–è¿­ä»£å™¨

### `std::set<T>`

- `insert(const T& value)`: æ’å…¥å…ƒç´ 
- `erase(const T& value)`: åˆ é™¤å…ƒç´ 
- `find(const T& value)`: æŸ¥æ‰¾å…ƒç´ 
- `size()`, `empty()`, `clear()`, `begin()`, `end()`: åŒ`std::vector`

### `std::map<K, V>`, `std::unordered_map<K, V>`

- `insert(std::make_pair(key, value))`: æ’å…¥é”®å€¼å¯¹
- `erase(const K& key)`: æ ¹æ®é”®åˆ é™¤å…ƒç´ 
- `find(const K& key)`: æŸ¥æ‰¾é”®
- `size()`, `empty()`, `clear()`, `begin()`, `end()`: åŒ`std::vector`

### `std::queue<T>`

- `push(const T& value)`: æ·»åŠ å…ƒç´ è‡³æœ«å°¾
- `pop()`: ç§»é™¤é¦–å…ƒç´ 
- `front()`: è·å–é¦–å…ƒç´ 
- `size()`, `empty()`: åŒ`std::vector`

### `std::stack<T>`

- `push(const T& value)`: æ·»åŠ å…ƒç´ è‡³é¡¶éƒ¨
- `pop()`: ç§»é™¤é¡¶éƒ¨å…ƒç´ 
- `top()`: è·å–é¡¶éƒ¨å…ƒç´ 
- `size()`, `empty()`: åŒ`std::vector`

### `std::priority_queue<T>`

- `push(const T& value)`: æ’å…¥å…ƒç´ 
- `pop()`: ç§»é™¤é¡¶éƒ¨å…ƒç´ 
- `top()`: è·å–é¡¶éƒ¨å…ƒç´ 
- `size()`, `empty()`: åŒ`std::vector`

### std::string

æ„é€ å‡½æ•°

- `string()` - åˆ›å»ºä¸€ä¸ªç©ºå­—ç¬¦ä¸²
- `string(const string& str)` - æ‹·è´æ„é€ å‡½æ•°
- `string(const char* s)` - ä» C å­—ç¬¦ä¸²æ„é€ 
- `string(size_t n, char c)` - ä½¿ç”¨ n ä¸ªå­—ç¬¦ c æ„é€ 

å…ƒç´ è®¿é—®

- `at(size_t pos)` - è®¿é—®æŒ‡å®šä½ç½®çš„å­—ç¬¦ï¼ˆå¸¦è¾¹ç•Œæ£€æŸ¥ï¼‰
- `operator[](size_t pos)` - è®¿é—®æŒ‡å®šä½ç½®çš„å­—ç¬¦
- `back()` - è®¿é—®æœ€åä¸€ä¸ªå­—ç¬¦
- `front()` - è®¿é—®ç¬¬ä¸€ä¸ªå­—ç¬¦

ä¿®æ”¹å™¨

- `append(const string& str)` - è¿½åŠ å­—ç¬¦ä¸²
- `push_back(char c)` - è¿½åŠ å­—ç¬¦
- `insert(size_t pos, const string& str)` - æ’å…¥å­—ç¬¦ä¸²
- `erase(size_t pos = 0, size_t len = npos)` - åˆ é™¤å­å­—ç¬¦ä¸²
- `replace(size_t pos, size_t len, const string& str)` - æ›¿æ¢å­å­—ç¬¦ä¸²
- `clear()` - æ¸…é™¤å†…å®¹
- `swap(string& str)` - äº¤æ¢å†…å®¹

å®¹é‡

- `size()` - è¿”å›å­—ç¬¦ä¸²é•¿åº¦
- `length()` - è¿”å›å­—ç¬¦ä¸²é•¿åº¦ï¼ˆä¸ `size()` ç›¸åŒï¼‰
- `empty()` - æ£€æŸ¥å­—ç¬¦ä¸²æ˜¯å¦ä¸ºç©º
- `resize(size_t n, char c)` - æ”¹å˜å¤§å°

æŸ¥æ‰¾

- `find(const string& str, size_t pos = 0) const` - æŸ¥æ‰¾å­å­—ç¬¦ä¸²
- `rfind(const string& str, size_t pos = npos) const` - ä»å³ä¾§å¼€å§‹æŸ¥æ‰¾å­å­—ç¬¦ä¸²

### std::deque

æ„é€ å‡½æ•°

- `deque()` - åˆ›å»ºä¸€ä¸ªç©ºåŒç«¯é˜Ÿåˆ—
- `deque(size_t n, const T& value)` - åˆ›å»ºåŒ…å« n ä¸ªå…ƒç´ çš„åŒç«¯é˜Ÿåˆ—

å…ƒç´ è®¿é—®

- `at(size_t pos)` - è®¿é—®æŒ‡å®šä½ç½®çš„å…ƒç´ ï¼ˆå¸¦è¾¹ç•Œæ£€æŸ¥ï¼‰
- `operator[](size_t pos)` - è®¿é—®æŒ‡å®šä½ç½®çš„å…ƒç´ 
- `front()` - è®¿é—®ç¬¬ä¸€ä¸ªå…ƒç´ 
- `back()` - è®¿é—®æœ€åä¸€ä¸ªå…ƒç´ 

ä¿®æ”¹å™¨

- `push_back(const T& value)` - åœ¨æœ«å°¾æ’å…¥å…ƒç´ 
- `push_front(const T& value)` - åœ¨å¼€å¤´æ’å…¥å…ƒç´ 
- `pop_back()` - ç§»é™¤æœ«å°¾å…ƒç´ 
- `pop_front()` - ç§»é™¤å¼€å¤´å…ƒç´ 
- `insert(iterator pos, const T& value)` - åœ¨æŒ‡å®šä½ç½®æ’å…¥å…ƒç´ 
- `erase(iterator pos)` - åˆ é™¤æŒ‡å®šä½ç½®çš„å…ƒç´ 
- `clear()` - æ¸…é™¤å†…å®¹
- `swap(deque& x)` - äº¤æ¢å†…å®¹

å®¹é‡

- `size()` - è¿”å›é˜Ÿåˆ—çš„å¤§å°
- `empty()` - æ£€æŸ¥é˜Ÿåˆ—æ˜¯å¦ä¸ºç©º
- `resize(size_t n, value_type val = value_type())` - æ”¹å˜å¤§å°

### â¤å¤„ç†å­—ç¬¦ä¸²ç›¸å…³ï¼š

getline

```text
std::string line;
std::getline( cin, line ); // ä»æ ‡å‡†è¾“å…¥è¯»å–ä¸€æ•´è¡Œ
```

stringstream

- `str()`: è·å–æˆ–è®¾ç½®æµä¸­çš„å­—ç¬¦ä¸²å†…å®¹
- `get()`: è·å–ä¸‹ä¸€ä¸ªå­—ç¬¦
- `<<`: æ’å…¥æ“ä½œç¬¦ï¼Œå°†æ•°æ®æ’å…¥åˆ°æµä¸­
- `>>`: æå–æ“ä½œç¬¦ï¼Œä»æµä¸­æå–æ•°æ®
- `clear()`: æ¸…é™¤æµçš„çŠ¶æ€æ ‡å¿—
- `peek()`: æŸ¥çœ‹ä¸‹ä¸€ä¸ªå­—ç¬¦

`"1,234,567"`å»æ‰é€—å·ï¼Œå¯ä»¥é€šè¿‡ä»¥ä¸‹æ–¹æ³•æ¥å®ç°ï¼š

```text
  string input = "1,234,567";
  string output;
  stringstream ss(input);
  
  char ch;
// æ³•ä¸€
  while (ss >> ch) {
    if (ch != ',') {
      output += ch;
    }
  }
// æ³•äºŒ
  while (ss.peek() != EOF) { // æŸ¥çœ‹ä¸‹ä¸€ä¸ªå­—ç¬¦ï¼Œä½†ä¸æå–
    char ch = ss.get(); // ä»æµä¸­æå–ä¸‹ä¸€ä¸ªå­—ç¬¦
    if (ch != ',') {
      output += ch;
    }
  }
```



### â¤**C å­—ç¬¦ä¸²å¤„ç†å‡½æ•°:**

å­—ç¬¦ä¸²é•¿åº¦

- - `strlen(const char* str)` - è¿”å›å­—ç¬¦ä¸² `str` çš„é•¿åº¦

å­—ç¬¦ä¸²æ¯”è¾ƒ

- - `strcmp(const char* str1, const char* str2)` - æ¯”è¾ƒä¸¤ä¸ªå­—ç¬¦ä¸²ã€‚å¦‚æœç›¸ç­‰è¿”å› 0ï¼Œ`str1` å¤§äº `str2` è¿”å›æ­£æ•°ï¼Œ`str1` å°äº `str2` è¿”å›è´Ÿæ•°
  - `strncmp(const char* str1, const char* str2, size_t n)` - æ¯”è¾ƒä¸¤ä¸ªå­—ç¬¦ä¸²çš„å‰ `n` ä¸ªå­—ç¬¦

å­—ç¬¦ä¸²æ‹·è´

- - `strcpy(char* dest, const char* src)` - å°† `src` å­—ç¬¦ä¸²æ‹·è´åˆ° `dest`
  - `strncpy(char* dest, const char* src, size_t n)` - å°† `src` çš„å‰ `n` ä¸ªå­—ç¬¦æ‹·è´åˆ° `dest`

å­—ç¬¦ä¸²è¿æ¥

- - `strcat(char* dest, const char* src)` - å°† `src` å­—ç¬¦ä¸²è¿½åŠ åˆ° `dest` æœ«å°¾
  - `strncat(char* dest, const char* src, size_t n)` - å°† `src` çš„å‰ `n` ä¸ªå­—ç¬¦è¿½åŠ åˆ° `dest` æœ«å°¾

å­—ç¬¦ä¸²æŸ¥æ‰¾

- - `strstr(const char* a, const char* b)` - åœ¨ a ä¸­æŸ¥æ‰¾ç¬¬ä¸€æ¬¡å‡ºç° `b`çš„ä½ç½®

å…¶ä»–

- - `memset(void* ptr, int value, size_t num)` - å°† `ptr` å¼€å§‹çš„ `num` å­—èŠ‚è®¾ç½®ä¸º `value`
  - `memcpy(void* dest, const void* src, size_t num)` - ä» `src` æ‹·è´ `num` å­—èŠ‚åˆ° `dest`
  - `memmove(void* dest, const void* src, size_t num)` - ä¸ `memcpy` ç±»ä¼¼ï¼Œä½†å¤„ç†é‡å åŒºåŸŸ



### â¤æ¯”è¾ƒå‡½æ•°

è¶…çº§å®¹æ˜“æ··æ·†ï¼Œè®°å¿†ç‚¹æ€»ç»“ï¼š

- sort é»˜è®¤å°çš„ä¼˜å…ˆï¼Œå³å‡åºã€‚[ä¼˜å…ˆé˜Ÿåˆ—](https://zhida.zhihu.com/search?content_id=232516329&content_type=Article&match_order=1&q=ä¼˜å…ˆé˜Ÿåˆ—&zhida_source=entity)é»˜è®¤å¤§é¡¶ã€‚
- ç”¨ > çš„æ¯”è¾ƒå‡½æ•°ä¸ std::greater åŒä¹‰ï¼Œéƒ½æ˜¯å¤§çš„ä¼˜å…ˆã€‚
- sort ç”¨ greater æˆ– > çš„å«ä¹‰æ˜¯å¤§çš„ä¼˜å…ˆã€‚ä¼˜å…ˆé˜Ÿåˆ—ç›¸åã€‚
- åªæœ‰sortå¯ä»¥ç›´æ¥ç”¨lambdaè¡¨è¾¾å¼ï¼Œstléœ€è¦ç”¨æœ‰æ¯”è¾ƒå‡½æ•°çš„ç±»å‹ã€‚

```cpp
sort(v.begin(), v.end()); // å‡åº
sort(v.begin(), v.end(), less<int>()); // åŒé»˜è®¤ï¼Œå‡åºæ’åº
sort(v.begin(), v.end(), greater<int>()); // é™åº
sort(v.begin(), v.end(), [](int a, int b) { return a > b; }); // é™åºæ’åº
sort(v.begin(), v.end(), [](int a, int b) { return a < b; }); // å‡åºæ’åº


priority_queue<int> pq; // æœ€å¤§å…ƒç´ ä¼˜å…ˆ
priority_queue<int, std::vector<int>, less<int> > pq; // åŒé»˜è®¤ï¼Œæœ€å¤§å…ƒç´ ä¼˜å…ˆ
priority_queue<int, std::vector<int>, greater<int> > pq; // æœ€å°å…ƒç´ ä¼˜å…ˆ


struct Person {
    int age;
    std::string name;
};
struct CompareAge {
    bool operator()(const Person& a, const Person& b) const {
        return a.age < b.age;
    }
};
std::set< Person , CompareAge > s;
std::priority_queue< Person, std::vector<Person> , CompareAge  > q;
```

## 8.26  

### å¿«é€Ÿæ’åº-acwing

```c++

/**
 * å¿«é€Ÿæ’åºç®—æ³•çš„å®ç°
 *
 *  q å¾…æ’åºçš„æ•´æ•°æ•°ç»„
 *  l æ•°ç»„çš„å·¦è¾¹ç•Œ
 *  r æ•°ç»„çš„å³è¾¹ç•Œ
 */
#include <iostream>
#include <algorithm>
using namespace std;
#define maxn 100100
//æ­¤å¤„åº”è¯¥æ˜¯#define maxn 10010
è€Œä¸æ˜¯ #define maxn = 10010;
ä¸ç”¨åˆ†å·å’Œç­‰å·


void quick_sort(int q[],int l,int r)
//æ­¤å¤„ä¸­é—´ç”¨é€—å·éš”å¼€ï¼Œè€Œéåˆ†å·
{
if(l>=r) return;
int i = l-1,j=r+1, x = q[(i + j)/2];
    //æ­¤å¤„é™¤å·åº”ä¸º>>
while(i<j)
{
    do i++;while(q[i]<x);
    do j--;while(q[j]>x);//æ­¤å¤„ä¸º--
    if(i<j) swap(q[i],q[j]);
}
quick_sort(q,l,j);
quick_sort(q,j+1,r);
}
int main()
{
int q[maxn];//æ­¤å¤„ä¸éœ€è¦={0}
int n;
cin>>n;
for(int i=0;i<n;i++)
{
    cin>>q[i];
}
quick_sort(q,0,n-1);//æ­¤å¤„æ³¨æ„è¾¹ç•Œ
for(int i=0;i<n;i++)
{
    cout<<q[i]<<" ";
}
}
```

### ç¬¬kä¸ªæ•°-acwing

```c++
#include<iostream>
#include<algorithm>
using namespace std;
#define maxn 100010
int q[maxn];
void quick_sort(int q[],int l,int r)
{
    if(l>=r) return;
    int i = l-1,j=r+1,x = q[i+j>>1];//æ³¨æ„æ­¤å¤„i=l-1 è€Œél+1
    while(i<j){
        do i++;while(q[i]<x);
        do j--;while(q[j]>x);
        if(i<j) swap(q[i],q[j]);
    }
    quick_sort(q,l,j);
    quick_sort(q,j+1,r);
}
int main()
{
    int n,k;
    cin>>n,cin>>k;
    for(int i = 0;i<n;i++)
    {
        cin>>q[i];
    }
    quick_sort(q,0,n-1);
    cout<<q[k-1];
}
```

## 9.1 dynamic planning acwing

### 0-1èƒŒåŒ…

```c++
#include <iostream>
#include <algorithm>
using namespace std;
const int N = 1010;
int W[N],V[N];
int f[N][N];//æ­¤å¤„å…¨å±€å˜é‡é»˜è®¤ä¸ºå…¨0
int n,m;
int main()
{
    cin>>n>>m;
    for(int i = 1;i<=n;i++)
     cin>>V[i]>>W[i];
    for(int i = 1;i<=n;i++)//æ­¤å¤„å¾ªç¯æ³¨æ„æ˜¯ç­‰å·ï¼Œå’Œå¹³æ—¶ä¹ æƒ¯ä¸å¤ªä¸€æ ·
        for(int j = 0;j <= m;j++){
        f[i][j] = f[i-1][j];
        if(j>=V[i]) f[i][j] = max(f[i][j],f[i-1][j-V[i]]+W[i]);
        }
        cout<<f[n][m]<<endl;
        return 0;
}
```

### å®Œå…¨èƒŒåŒ…é—®é¢˜

```c++
#include <iostream>
#include <algorithm>
using namespace std;
const int N =1010;
int f[N][N];
int V[N],W[N];
int n,m;
int main()
{
    cin>>n>>m;
    for(int i = 1;i<=n;i++)
    cin>>V[i]>>W[i];
    for(int i = 1;i<=n;i++)
        for(int j =0;j<=m;j++){
        f[i][j] = f[i-1][j];
        if(j>=V[i]) f[i][j] = max(f[i][j],f[i][j-V[i]]+W[i]);
        }
        cout<<f[n][m]<<endl;
        return 0;
}
```

## 9.4

### â¤å¤šé‡èƒŒåŒ…é—®é¢˜II

```c++
#include<iostream>
using namespace std;

const int N = 12010, M = 2010;

int n, m;
int v[N], w[N]; //é€ä¸€æšä¸¾æœ€å¤§æ˜¯N*logS
int f[M]; // ä½“ç§¯<M

int main()
{
    cin >> n >> m;
    int cnt = 0; //åˆ†ç»„çš„ç»„åˆ«
    for(int i = 1;i <= n;i ++)
    {
        int a,b,s;
        cin >> a >> b >> s;
        int k = 1; // ç»„åˆ«é‡Œé¢çš„ä¸ªæ•°
        while(k<=s)
        {
            cnt ++ ; //ç»„åˆ«å…ˆå¢åŠ 
            v[cnt] = a * k ; //æ•´ä½“ä½“ç§¯
            w[cnt] = b * k; // æ•´ä½“ä»·å€¼
            s -= k; // sè¦å‡å°
            k *= 2; // ç»„åˆ«é‡Œçš„ä¸ªæ•°å¢åŠ 
        }
        //å‰©ä½™çš„ä¸€ç»„
        if(s>0)
        {
            cnt ++ ;
            v[cnt] = a*s; 
            w[cnt] = b*s;
        }
    }//æ³¨æ„æ‹¬å·

    n = cnt ; //æšä¸¾æ¬¡æ•°æ­£å¼ç”±ä¸ªæ•°å˜æˆç»„åˆ«æ•°

    //01èƒŒåŒ…ä¸€ç»´ä¼˜åŒ–
    for(int i = 1;i <= n ;i ++)
        for(int j = m ;j >= v[i];j --)
            f[j] = max(f[j],f[j-v[i]] + w[i]);

    cout << f[m] << endl;
    return 0;
}
```

## 9.5

### æœ€é•¿ä¸Šå‡å­åºåˆ—

```cpp
#include <iostream>
#include <algorithm>
using namespace std;
const int N = 1010;
int f[N];
int W[N];
int main()
{
    int mx = 0;
    int n;
    cin>>n;
    for(int i = 1; i <= n ;i++)
    {
        cin>>W[i];
    }
    for(int i = 1; i <= n ;i++)
    {
        f[i] = 1;
        for(int j  = 1 ; j<i ; j++)
        if(W[i]>W[j]) f[i] = max(f[j]+1,f[i]);
    }
    for(int i = 1;i <= n ; i ++)
    mx = max(f[i],mx);
    cout<<mx;
    return 0;
}
```

### æ•°å­—ä¸‰è§’å½¢

```cpp
#include <iostream>
using namespace std;
const int N = 510;
#define INF  -1e9;
int f[N][N];
int W[N][N];
int main()
{
    int n;
    cin>>n;
    int mx= INF ;
    for(int i = 1 ; i <= n ; i++ )
        for(int j = 0;j <= n;j++){//æ­¤å¤„æ³¨æ„ä»0å¼€å§‹
        W[i][j] = INF;
        f[i][j] = INF;
        }
    for(int i = 1 ; i <= n ; i++ )
        for(int j = 1;j <= i;j++ )
        {
            cin>>W[i][j];
        }
    for(int i = 1 ; i <= n ; i++ )
        for(int j = 1;  j<=i    ;j++ )
        f[i][j] = max(f[i-1][j-1]+W[i][j],f[i-1][j]+W[i][j]);
    for(int j = 1;  j <= n    ;j++ )
    mx = max(mx,f[n][j]);
    cout<<mx<<endl;
    return 0;
}
```



### æœ€é•¿å…¬å…±å­åºåˆ—

```cpp
#include <iostream>
using namespace std;
const int N  = 1010;
char A[N],B[N];
int f[N][N];
int main()
{
    int n,m;
    scanf("%d%d",&n,&m);
    scanf("%s%s",A+1,B+1);
    for(int i = 1;i<=n; i ++)
        for(int j = 1;j<=m; j ++)
        {
            f[i][j] = max(f[i-1][j],f[i][j-1]);
            if(A[i]==B[j]) f[i][j] = max(f[i][j],f[i-1][j-1]+1);//ä¸æ˜¯=
        }
        printf("%d",f[n][m]);
        return 0;
}
```

## 9.6

### åˆå¹¶çŸ³å­

```cpp
#include <iostream>
#include <algorithm>
using namespace std;
const int N = 310;
int f[N][N];

int S[N];
const int INF = 1e8;
int main()
{
int n ;
cin >> n;
//memset(f[N][N])= INF;
for(int i = 1;i <=n ; i++)
{
    cin>>S[i];
}
for(int i = 1;i <= n ; i++)
{
    S[i] += S[i-1];
    //printf("S[%d]=%d\n",i,S[i]);
}
//printf("n = %d\n",n);
for(int len = 2 ; len <= n ; len ++)
{
   // printf("æ‰§è¡Œlen = %d\nn = %d\ncs =%d\n",len,n,len <= n);
    for(int i = 1; i + len -1 <= n ; i++)
    {
        int l = i, r = i + len -1;
        f[l][r] = 1e9;//è¿™é‡Œåˆ«å¿˜äº†åˆå§‹åŒ–
        for(int k = l ;k < r;k++)
        {
            f[l][r] = min(f[l][r],f[l][k]+f[k+1][r]+S[r]-S[l-1]);
            //printf("f[%d][%d]=%d\n",l,r,f[l][r]);
        }
        //return 0;
    }
} 
cout<<f[1][n]<<endl;//å†™çš„æ—¶å€™ä¸å°å¿ƒè¿›å¾ªç¯äº†
return 0;//è¿™ä¸ªè¿›å¾ªç¯ä¼šå¯¼è‡´ç¨‹åºåªæ‰§è¡Œä¸€æ¬¡ï¼Œæœç„¶æœºå™¨æ°¸è¿œä¸ä¼šå‡ºé”™
}
```

## 9.28 LChot100 hashmap 

### 1.ä¸¤æ•°ä¹‹å’Œ

```cpp
//leetcode 1.ä¸¤æ•°ä¹‹å’Œ
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        unordered_map<int,int> hash_map;//è¿™é‡Œç”¨åˆ°æ•°æ®ç»“æ„å“ˆå¸Œè¡¨
        for(int i = 0;i < nums.size(); i++){
            auto it = hash_map.find(target - nums[i]);//éå†æ•°ç»„ï¼Œå¦‚æœæ‰¾åˆ°ç»“æœè¿”å›åˆ°it
            if(it != hash_map.end())
                return {it->second,i};
            hash_map[nums[i]] = i;
        }
        return {};//å¿…é¡»æ¯ä¸€ä¸ªåˆ†æ”¯éƒ½èƒ½è¿”å›æ•°å€¼
    }
};
```

å¯¹STLå®¹å™¨ä¸ç†Ÿæ‚‰

### 49.å­—æ¯å¼‚ä½è¯åˆ†ç»„

```cpp
 vector<vector<string>> groupAnagrams(vector<string>& strs) {
        //vector<vector<string>> result;
        unordered_map<string,vector<string>> hashtable;
        for(int i = 0;i<strs.size();i++)
        {
            string key = strs[i];
            sort(key.begin(),key.end());
            hashtable[key].push_back(strs[i]);
        }
        vector<vector<string>> ans;
        for(auto it = hashtable.begin();it!=hashtable.end();it++)
        ans.push_back(it->second);
        return ans;
    }
```

é¢˜è§£ï¼šhttps://www.bilibili.com/video/BV1vP4y1F7A6/?spm_id_from=333.337.search-card.all.click&vd_source=29f25fe9fa4a2863c90bcdd8fffe07ce

### 128.æœ€é•¿è¿ç»­åºåˆ—

```cpp
 int longestConsecutive(vector<int>& nums){     
		unordered_set<int> hashtable(nums.begin(),nums.end());
        int ans = 0;
        for(int num : hashtable)
        {   
            int x = num;
            if(!hashtable.count(x-1))
            while(hashtable.count(x)) x++;
            ans  = max(ans,x-num);
        }
        return ans;
    }
```

## 9.29 LChot100  åŒæŒ‡é’ˆ

### 283.ç§»åŠ¨é›¶

``` cpp
void moveZeroes(vector<int>& nums) {
      int j  = 0 ;
      for(int i = 0 ;i<nums.size() ; i++)
      {
          if(nums[i]){            
          swap(nums[i],nums[j]);
          j++;
      }
    }
```

### â¤11.ç››æœ€å¤šæ°´çš„å®¹å™¨

```cpp
int maxArea(vector<int>& height) {
        int right = height.size()-1;
        int left = 0;
        int mx = 0;
        while(left<right){
            mx = max(mx,min(height[left],height[right])*(right-left));
            if(left<right&&height[right]<height[left]) 				right--;
            else  left++;
        }
        return mx;
    }
```

æ­¤é¢˜èŒƒå¼

### â¤15.ä¸‰æ•°ä¹‹å’Œ

```cpp
    vector<vector<int>> threeSum(vector<int>& nums) {
    vector<vector<int>> ans;
    sort(nums.begin(),nums.end());//å…ˆæ’åº
    int left,right = 0;
    for(int i = 0  ; i < nums.size()-1;i++)
    {
        if (nums[i] > 0) 
        return ans;//è‹¥ç¬¬ä¸€ä¸ªæ•°å¤§äº0ï¼Œåˆ™ç›´æ¥è¿”å›
        if(i>0&&nums[i]==nums[i-1]) continue;//å¦‚æœå†™åœ¨whileé‡Œé¢ä¼šå¯¼è‡´000é€šä¸è¿‡
        left = i+1,right = nums.size()-1;//å·¦å³æŒ‡é’ˆå‘ä¸­é—´é€¼è¿‘
        while(left<right){//ç»å…¸åŒæŒ‡é’ˆå¾ªç¯ç»“æ„
        if(nums[i]+nums[left]+nums[right]>0) right--;
            //ä¾é if else è¿›è¡Œè¡Œä¸ºé€‰æ‹©
            //å¤§äºåˆ™å³æŒ‡é’ˆå‘å·¦ç§»
        else if(nums[i]+nums[left]+nums[right]<0) left++;
            //å°äºåˆ™å·¦æŒ‡é’ˆå‘å³ç§»
        else{//ç­‰äºçš„æƒ…å†µ
        ans.push_back(vector<int>{nums[i],nums[left],nums[right]});//å°†æ­¤æ—¶çš„ä¸‰å…ƒç»„å‹æ ˆ
        while(right>left&&nums[right]==nums[right-1]) 			right--;//å»é‡
        while(right>left&&nums[left]==nums[left+1]) 			left++;//å»é‡
        left++;//ç»“å°¾å‘ä¸­é—´
        right--;
                }
         }
    }
    return ans;
    }
```

æ­¤é¢˜ç‰¹åˆ«æ³¨æ„å»é‡ï¼

## 9.30 LChot100 å•è°ƒæ ˆ

### â¤â¤ç»å…¸42.æ¥é›¨æ°´

è§£æ³•ä¸€ï¼šåŠ¨æ€è§„åˆ’

è§£æ³•äºŒï¼šå•è°ƒæ ˆ

è§£æ³•ä¸‰ï¼šåŒæŒ‡é’ˆ

### 739.æ¯æ—¥æ¸©åº¦

è§£æ³•ä¸€ï¼šæš´åŠ› time exceeding

```cpp
    vector<int> dailyTemperatures(vector<int>& temperatures) {
        vector<int> ans;
        for(int i = 0 ; i <= temperatures.size()-1 ; i ++){
            for(int j = i + 1 ; j <= temperatures.size();j++){
                if(j<temperatures.size()&&temperatures[i]<temperatures[j]){
                ans.push_back(j-i);
                break;
                }
                else if(j==temperatures.size()){
                    ans.push_back(0);
                    break;
                }
                
            }
        }
        return ans;
    }
```

è§£æ³•äºŒï¼šå•è°ƒæ ˆ

```cpp
vector<int> dailyTemperatures(vector<int>& temperatures) {
    stack<int> st;
    vector<int> ans(temperatures.size(),0);
    for(int i = 0;i < temperatures.size();i ++){
    while(!st.empty()&&temperatures[st.top()]<temperatures[i]){
        ans[st.top()] = i - st.top();
        st.pop();
    	}
       st.push(i);
    }
    return ans;
}
```

## 10.1 è¿˜æ¥é›¨æ°´å—ï¼Ÿ

### 42.æ¥é›¨æ°´ï¼ˆå•è°ƒæ ˆè§£æ³•ï¼‰

ä¸€æ®µæ€ä¹ˆéƒ½è¿‡ä¸äº†çš„ç¥ç§˜ä»£ç 

```cpp
class Solution {
public:
    int trap(vector<int>& height) {
        stack<int> st;
        int sum = 0;
        st.push(0);
        for (int i = 0; i < height.size(); i++) {
            if (height[i] < height[st.top()])
                st.push(i);
            else if (height[i] == height[st.top()]) {
                st.pop();
                st.push(i);
            } else {
                while (!st.empty() && height[i] > height[st.top()]) {
                    int mid = height[st.top()];
                    st.pop();
                    if (!st.empty()) {
                        int h = min(height[st.top()], height[i]) - mid;
                        int w = i - st.top() - 1; // è¿™é‡Œåº”è¯¥æ˜¯ç”¨ä¸‹æ ‡ç›´æ¥ç®—
                        sum += h * w;
                    }
                }
                st.push(i); // è¿™é‡Œæ²¡åŠ ï¼Œå¯¼è‡´ç¼–è¯‘å‡ºé”™
            }
        }
        return sum;
    }
};
```

### 53.æœ€å¤§å­æ•°ç»„å’Œ(dp)

```cpp
class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        int pre = 0 ,maxAns = nums[0];
        for(int x:nums){
            pre = max(pre+x,x);
            maxAns = max(maxAns,pre);
        }
        return maxAns;
        }
    }
};
```

### 560.å’Œä¸ºkçš„å­æ•°ç»„ï¼ˆæš´åŠ›acï¼‰

```
    int subarraySum(vector<int>& nums, int k) {
        int sum = 0;
        int ans = 0;
        for(int i = 0;i < nums.size() ; i++){
            sum += nums[i];
            if(sum == k) ans++;
            for(int j = i+1 ; j < nums.size() ; j++){
                sum += nums[j];
                if(sum == k) ans++;
            }
            sum = 0;
        }
        return ans;
    }
```

## 10.2	æ»‘åŠ¨çª—å£ å•è°ƒé˜Ÿåˆ— è´ªå¿ƒ

### 239.æ»‘åŠ¨çª—å£æœ€å¤§å€¼ï¼ˆå•è°ƒé˜Ÿåˆ—ï¼‰

```cpp
class Solution {
private:
    class myQueue {
    public:
        deque<int> que;
        void pop(int val) {
            if (!que.empty() && que.front() == val) {
                que.pop_front();
            }
        }
        void push(int val) {
            while (!que.empty()&&que.back() < val) {//ä¸ºå•¥è¿™é‡Œäº¤æ¢ä¸ªé¡ºåºå°±èƒ½ACï¼Ÿ
                que.pop_back();
            }
            que.push_back(val);
        }
        int front() { return que.front(); }
    };

public:
    vector<int> maxSlidingWindow(vector<int>& nums, int k) {
        myQueue que;
        vector<int> ans;
        for (int i = 0; i < k; i++) {
            que.push(nums[i]);
        }
        ans.push_back(que.front());
        for (int i = k; i < nums.size(); i++) {
            que.pop(nums[i - k]);
            que.push(nums[i]);
            ans.push_back(que.front());
        }
        return ans;
    }
};
```

### 56.åˆå¹¶åŒºé—´ï¼ˆè´ªå¿ƒï¼‰

```cpp
class Solution {
public:
    vector<vector<int>> merge(vector<vector<int>>& intervals) {
        vector<vector<int>> ans;
        sort(intervals.begin(), intervals.end(), [](const vector<int>& a, const vector<int>& b){return a[0] < b[0];});//è¿™é‡Œæ˜¯sortç”¨æ³•
        ans.push_back(intervals[0]);
        for(int i = 1 ; i < intervals.size() ; i ++)		{
            if(intervals[i][0] <= ans.back()[1])
            ans.back()[1] = max(ans.back()[1],intervals[i][1]);
            else{
                ans.push_back(intervals[i]);
            }
        }
        return ans;
        }
    };

```

### 189.è½®è½¬æ•°ç»„

```cpp
class Solution {
public:
    void rotate(vector<int>& nums, int k) {
        k %= nums.size();
        reverse(nums.begin(),nums.end());
        reverse(nums.begin(),nums.begin()+k);
        reverse(nums.begin()+k,nums.end());
        }
    };
```

## 10.3 æ»‘åŠ¨çª—å£

### 3.æ— é‡å¤å­—ç¬¦çš„æœ€å¤§å­—ä¸²

```cpp
class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        int ans = 0;
        unordered_set<char> occ;
        int n = s.size();
        int rk = -1;
        for(int i  = 0 ; i < n ; i ++){
            if(i != 0){
                occ.erase(s[i-1]);
            }
            while(rk + 1 < n&& !occ.count(s[rk+1])){
                occ.insert(s[rk+1]);
                rk++;//åˆæ¼åŠ›
            }
            ans = max(ans,rk+1-i);
        }
        return ans;
    }
};
```

### 238.é™¤è‡ªèº«ä»¥å¤–æ•°ç»„çš„ä¹˜ç§¯

```cpp
class Solution {
public:
    vector<int> productExceptSelf(vector<int>& nums) {
        int n = nums.size();
        vector<int> ans(n, 1);
        // è®¡ç®—å·¦è¾¹å…ƒç´ çš„ä¹˜ç§¯
        int left = 1;//æ³¨æ„ä¸èƒ½å†™æˆint leftï¼Œright = 1
        for (int i = 0; i < n; i++) {
            ans[i] *= left;
            left *= nums[i];
        }
        // è®¡ç®—å³è¾¹å…ƒç´ çš„ä¹˜ç§¯å¹¶ä¸å·¦è¾¹å…ƒç´ çš„ä¹˜ç§¯ç›¸ä¹˜
        int right = 1;
        for (int i = n - 1; i >= 0; i--) {
            ans[i] *= right;
            right *= nums[i];
        }
        return ans;
    }
};
```

## 10.5

### 41.ç¼ºå¤±çš„ç¬¬ä¸€ä¸ªæ­£æ•°

è§£æ³•ä¸€ï¼šå“ˆå¸Œæš´åŠ›ï¼Œç©ºé—´å¤æ‚åº¦Oï¼ˆnï¼‰

```cpp
class Solution {
public:
    int firstMissingPositive(vector<int>& nums) {
        unordered_map<int,int> hashtable;
        int ans = 0;
        for(int i = 0 ; i < nums.size() ; i++){
            hashtable[nums[i]] = i;
        }
        //sort(nums.begin(),nums.end());
        for(int i = 0 ; i < 2147483648 ; i++){
            if(!hashtable.count(i+1)){
                ans = i+1; 
                break;
            }
        }
        return ans;
    }
};
```

è§£æ³•äºŒï¼šç½®æ¢æ³•

```cpp
class Solution {
public:
    int firstMissingPositive(vector<int>& nums) {
        int ans = 0;
        int i = 0;
        if(nums.size()==1){ 
            if(nums[0]<=0) return 1;
                else if(nums[0] == 1) return 2;
                    else return 1;
        }
        for(int i = 0 ; i < nums.size() ; i ++){
            while(nums[i] >= 1 && nums[i] <= nums.size() && nums[nums[i]-1] != nums[i]) //æ³¨æ„ç”¨whileè€Œä¸æ˜¯if
                swap(nums[i],nums[nums[i]-1]);   
        }
        for(i  = 0 ; i  < nums.size() ; i++){
            if(nums[i] != i+1){
                return i+1;
            } 
        }
        return nums.size()+1;
    }
};
```

### 438.æ‰¾åˆ°å­—ç¬¦ä¸²ä¸­æ‰€æœ‰çš„å­—æ¯å¼‚ä½è¯ï¼ˆæ€è€ƒä¼˜åŒ–ï¼‰

æ»‘åŠ¨çª—å£

```cpp
class Solution {
public:
    vector<int> findAnagrams(string s, string p) {
        vector<int> ans;
        int n = p.size();
        int left = 0, right = n;
        if(s.size() < p.size()) return ans;
        vector<int> count(26);
        vector<int> compareCount(26);
        for(int i = 0 ; i < n ; i ++){
            count[p[i]-'a'] ++;
        }
        for(int i = 0 ; i < n-1 ; i ++){//n-1æ³¨æ„
            compareCount[s[i]-'a'] ++;
        }
        for(left = 0 , right = n-1 ; right<s.size() ; left++,right++){//n-1æ³¨æ„
            compareCount[s[right] - 'a'] ++;
            if(compareCount == count) 
                ans.push_back(left);
            compareCount[s[left] - 'a'] --;
        }
        return ans;
    }
};
```

## 10.6

### â¤76.æœ€å°è¦†ç›–å­ä¸² hard

```cpp
class Solution {
public:
    string minWindow(string s, string t) {
        unordered_map<char,int> hs,ht;
        string ans;
        for(int i = 0 ; i < t.size() ; i ++){
            ht[t[i]] ++;
        }
        for(int i = 0, j = 0 , cnt = 0; i < s.size() ; i ++){
            if(++hs[s[i]] <= ht[s[i]])
                cnt ++;//æœ‰æ•ˆè®¡æ•° 
            while (hs[s[j]] > ht[s[j]]) hs[s[j++]] --;//å·¦çª—å£ç§»åŠ¨
            if (cnt == t.size()) {
           		 if (ans.empty() || ans.size() > i-j+1)//è¿™ä¸ªæ¡ä»¶ç¡®å®šäº†æ‰¾åˆ°çš„ansæ˜¯æœ€å°çš„{
                    ans = s.substr(j, i - j +1 );
                }
            }
        }
        return ans;
    }   
};
```

### 73.çŸ©é˜µç½®é›¶

è§£æ³•ä¸€ï¼šæš´åŠ› ç©ºé—´å¤æ‚åº¦O(mn)

```cpp
class Solution {
public:
    void setZeroes(vector<vector<int>>& matrix) {
        vector<vector<int>> vec;
        int row = 0 , col = 0;
        for(int i = 0 ; i < matrix.size() ; i ++){
            for(int j = 0 ; j < matrix[0].size() ; j ++){
                if(matrix[i][j] == 0){
                    vec.push_back({i,j});
                }
            }
        }
        for(int i = 0 ; i < vec.size() ; i ++){
            row = vec[i][0];
            col = vec[i][1];
            for(int j = 0 ; j < matrix[0].size() ; j++)
            matrix[row][j] = 0;
            for(int k = 0; k < matrix.size() ; k++)
            matrix[k][col] = 0;
        }
    }
};
```

è§£æ³•äºŒï¼šç©ºé—´å¤æ‚åº¦O(1)

## 10.8

### 54.èºæ—‹çŸ©é˜µ

```cpp
class Solution {
public:
    vector<int> spiralOrder(vector<vector<int>>& matrix) {
        int u = 0, d = matrix.size() - 1 , l = 0, r = matrix[0].size() - 1;
        vector <int> ans;
        if(matrix.empty()) return ans;
        while(true){
            for(int i = l ; i <= r ; ++i) ans.push_back(matrix[u][i]);
            if(++u > d) break;
            for(int i = u ; i <= d ; ++i) ans.push_back(matrix[i][r]);
            if(--r < l) break;
            for(int i = r ; i >= l ; --i) ans.push_back(matrix[d][i]);
            if(--d < u) break;
            for(int i = d ; i >= u ; --i) ans.push_back(matrix[i][l]);
            if(++l > r) break;
        }
        return ans;
    }
};
```

### 48.æ—‹è½¬å›¾åƒ

```cpp
class Solution {
public:
    void rotate(vector<vector<int>>& matrix) {
        for(int i = 0 ; i < matrix.size() / 2 ; ++i){
            for(int j = 0 ; j < matrix[0].size() ; ++j){
                swap(matrix[i][j],matrix[matrix[0].size()-i-1][j]);
            }
        }
         for (int i = 0; i < matrix.size(); ++ i) {
            for (int j = 0; j < i; ++ j) {
                swap(matrix[i][j], matrix[j][i]);
            }
        }
    }
};
```

### 240.æœç´¢äºŒç»´çŸ©é˜µII

```cpp
class Solution {
public:
    bool searchMatrix(vector<vector<int>>& matrix, int target) {
        int m = matrix.size() , n = matrix[0].size() ; 
        int x = 0, y = n-1;
        while(x < m && y >= 0) {
            if(matrix[x][y] == target) 
                return true;
                else if(matrix[x][y] < target){
                    x++;
                }
                    else{
                        y--;      
                    }
        }
        return false;
    }
};
```

### 136.åªå‡ºç°ä¸€æ¬¡çš„æ•°å­—

è§£æ³•ä¸€ï¼šå“ˆå¸Œè¡¨

```cpp
class Solution {
public:
    int singleNumber(vector<int>& nums) {
        unordered_map<int,int> hashtable;
        for(int i = 0 ; i < nums.size() ; ++ i ){
            hashtable[nums[i]] ++;
        }
        for(auto it = hashtable.begin() ; it != hashtable.end() ; it ++){
            if(it->second == 1) return it->first;
        }
        return false;
    }
};
```

it->firstå’Œit->secondåˆ†åˆ«æ˜¯å•¥ï¼Ÿ

`it->first`å’Œ`it->second`çš„å«ä¹‰

å½“ä½¿ç”¨è¿­ä»£å™¨ï¼ˆå¦‚è¿™é‡Œçš„itï¼‰éå†unordered_mapæ—¶ï¼š

`it->first`ï¼šè¡¨ç¤ºå½“å‰è¿­ä»£å™¨æŒ‡å‘çš„é”® - å€¼å¯¹ä¸­çš„é”®ï¼ˆ`key`ï¼‰ã€‚ä¾‹å¦‚ï¼Œåœ¨ä»£ç ä¸­çš„`unordered_map<int, int>`ä¸­ï¼Œå¦‚æœé”®æ˜¯æ•´æ•°ç±»å‹ï¼Œ`it->first`å°±ä»£è¡¨è¿™ä¸ªæ•´æ•°é”®ã€‚

`it->second`ï¼šè¡¨ç¤ºå½“å‰è¿­ä»£å™¨æŒ‡å‘çš„é”® - å€¼å¯¹ä¸­çš„å€¼ï¼ˆ`value`ï¼‰ã€‚å¯¹äº`unordered_map<int, int>`ï¼Œ`it->second`å°±æ˜¯ä¸é”®ç›¸å¯¹åº”çš„æ•´æ•°å€¼ã€‚åœ¨è¿™æ®µä»£ç ä¸­ï¼Œ`hashtable[nums[i]]++`è¿™ä¸€æ“ä½œæ˜¯åœ¨ç»Ÿè®¡æ¯ä¸ªæ•°å­—ï¼ˆé”®ï¼‰åœ¨`nums`æ•°ç»„ä¸­å‡ºç°çš„æ¬¡æ•°ï¼ˆå€¼ï¼‰ã€‚ç„¶åé€šè¿‡éå†`hashtable`ï¼Œå½“æ‰¾åˆ°`it->second`ï¼ˆå³æŸä¸ªæ•°å­—å‡ºç°çš„æ¬¡æ•°ï¼‰ç­‰äº 1 æ—¶ï¼Œå°±è¿”å›`it->first`ï¼ˆè¿™ä¸ªåªå‡ºç°ä¸€æ¬¡çš„æ•°å­—ï¼‰ã€‚

## 10.9

### 160.ç›¸äº¤é“¾è¡¨

```C++
class Solution {
public:
    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
        auto p = headA;
        auto q = headB;
        auto ptr1 = headA;
        auto ptr2 = headB;
        int start = 0;
        int i = 0;
        int j = 0;
        int k = 0;
        for(;p!= NULL;p=p->next) i++;
        for(;q!= NULL;q=q->next) j++;
        k = (i-j>0)? i-j:j-i;
        if(i>j) 
        for(;k>0;k--) ptr1 = ptr1->next;
        else
        for(;k>0;k--) ptr2 = ptr2->next;
        for(;ptr1!=NULL;ptr1 = ptr1->next,ptr2 = ptr2->next)
        if(ptr1 == ptr2) return ptr1;
        return NULL;
    }
};
```

### 206.åè½¬é“¾è¡¨

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* reverseList(ListNode* head) { 
        ListNode* p = nullptr;
        ListNode* q = head;
        while(q){
            ListNode* o = q->next;
            q->next = p;
            p = q;
            q = o;
        }
        head = p;
        return head;
    }
};
```

### 141.ç¯å½¢é“¾è¡¨

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    bool hasCycle(ListNode *head) {
        if(head == nullptr) return false;
        ListNode *fast = head;
        ListNode *slow = head;
        while(fast->next!=nullptr&&fast->next->next!=nullptr){
            fast = fast->next;
            //if(fast == slow) return true;
            fast = fast->next;
            //if(fast == slow) return true;
            slow = slow->next;
            if(fast == slow) return true;
        }
        return false;
    }
};
```

## 10.10

### 142.ç¯å½¢é“¾è¡¨II

è§£æ³•ä¸€ï¼šå“ˆå¸Œé›†åˆ

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode *detectCycle(ListNode *head) {
        unordered_set<ListNode *> hashset;
        while(head != nullptr){
            if(hashset.count(head))
            return head;
        hashset.insert(head);
        head = head->next;
        }
        return nullptr;
    }
};
```

è§£æ³•äºŒï¼šå¿«æ…¢æŒ‡é’ˆ

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode *detectCycle(ListNode *head) {
        ListNode* fast = head;
        ListNode* slow = head; 
        while(fast!=nullptr&&fast->next!=nullptr){
            fast = fast->next->next;
            slow = slow->next;
            if(slow == fast){
                ListNode* ptr = head;
                while(ptr != slow){
                    ptr=ptr->next;
                    slow=slow->next;
                }
                return ptr;
            }
        }
        return nullptr;
    }
};
```

### â™¥234.å›æ–‡é“¾è¡¨

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    bool isPalindrome(ListNode* head) {
        ListNode *pre = nullptr;
        ListNode *fast = head, *slow = head;
        while (fast != nullptr && fast->next != nullptr) {
            fast = fast->next->next;
            slow = slow->next;
        }
        while (slow) {
            ListNode * tmp = slow->next;
            slow->next = pre;
            pre = slow;
            slow = tmp;
        }
        while (pre) {
            if (pre->val != head->val) 
                return false;
            pre = pre->next;
            head = head->next;
        }
        return true;
    }
};
```

### 21.åˆå¹¶ä¸¤ä¸ªæœ‰åºé“¾è¡¨

è§£æ³•ä¸€ï¼šé€’å½’

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {
        ListNode* l1 = list1;
        ListNode* l2 = list2;
        if(l1 == nullptr) return l2;
        else if(l2 == nullptr) return l1;
        else if(l1->val < l2->val) {
            l1->next = mergeTwoLists(l1->next,l2);
            return l1;
        }
        else {
            l2->next = mergeTwoLists(l2->next,l1);
            return l2;
        }
    }
};
```

### 19.åˆ é™¤å€’æ•°ç¬¬Nä¸ªèŠ‚ç‚¹

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* removeNthFromEnd(ListNode* head, int n) {
        ListNode* dummyHead = new ListNode(0);
        dummyHead->next = head;
        ListNode* fast = dummyHead;
        ListNode* slow = dummyHead;
        for(int k = n ; k > 0 ; k --){
            fast = fast->next;
        }
        fast = fast->next;
        while(fast){
            fast = fast->next;
            slow = slow->next;
        }
        slow->next = slow->next->next;
        return dummyHead->next;
    }
};
```

## 10.11

### ä¸¤ä¸¤äº¤æ¢é“¾è¡¨ä¸­çš„ç»“ç‚¹

æ³¨æ„ç”»å›¾åˆ†æ

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* swapPairs(ListNode* head) {
        ListNode *dummyHead = new ListNode(0);
        dummyHead->next = head;
        ListNode *cur = dummyHead;
        while(cur->next != nullptr && cur->next->next != nullptr){
            ListNode *tmp1 = cur->next;
            ListNode *tmp2 = cur->next->next->next;

            cur->next = tmp1->next;//æ­¥éª¤ä¸€
            cur->next->next = tmp1;//æ­¥éª¤äºŒ
            tmp1->next = tmp2;     //æ­¥éª¤ä¸‰

            cur  = cur->next->next;
        }
        ListNode* result = dummyHead->next;
        delete dummyHead;
        return result;
    }
};
```

## 10.13

### 25.kä¸ªä¸€ç»„é‡æ’é“¾è¡¨

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* reverseKGroup(ListNode* head, int k) {
        ListNode *dummyHead = new ListNode(0);
        dummyHead->next = head;

        ListNode *pre = dummyHead;
        ListNode *end = dummyHead;

        while(end->next != nullptr){
            for(int i = 0 ; i < k && end != nullptr ; i++) 
                end = end->next;
            if (end == nullptr) break;
            ListNode *start = pre->next;
            ListNode *next = end->next;
            end->next = nullptr;
            pre->next = reverse(start);
            start->next = next;
            pre = start;
            end = pre;
        } 
        return dummyHead->next;
    }
    private: 
        ListNode *reverse(ListNode* head){
            ListNode *pre = nullptr;
            ListNode *cur = head;
            while(cur != nullptr){
                ListNode *next = cur->next;
                cur->next = pre;
                pre = cur;
                cur = next;
        }
        return pre;
    } 
};
```

### 138.éšæœºé“¾è¡¨çš„å¤åˆ¶

```cpp
class Solution {
public:
    Node* copyRandomList(Node* head) {
        unordered_map< Node*, Node*> map;
        if(head == nullptr) return nullptr;
        Node* newHead = new Node(head->val);
        map[head] = newHead;
        Node* tmp = head->next;
        while(tmp != nullptr){
            map[tmp] = new Node(tmp->val); 
            tmp = tmp->next;
        } 
        tmp = head;
        while(tmp != nullptr){
            map[tmp]->next = map[tmp->next];
            map[tmp]->random = map[tmp->random];
            tmp = tmp->next;
        }
        return map[head];
    }
};
```

