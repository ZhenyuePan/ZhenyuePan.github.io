---
title: "技术栈八股整理"
publishedAt: "2025-4-16"
summary: "主要包括C++，操作系统，计算机网络，redis，mysql"
---

# C++

## C++中值传递和引用传递的区别

1.一个拷贝一个不拷贝

2.一个可以在函数中修改值，一个不能

常引用：省去拷贝的同时，保证了变量的安全性（值无法被修改）

## C与C++的区别

1.面向对象与面向对象的三大特性（封装继承多态）

2.内存管理（new，delete，智能指针）

3.STL标准库

4.模板

## 左值和右值的区别

左值：可以取地址的值

右值：常量，临时变量等不能取地址的值

应用：移动语义

## 什么是移动语义和完美转发

一种优化资源管理的机制，常规的资源管理是拷贝别人的资源，而移动语义是转移所有权，转移了资源而不是拷贝资源，性能会更好。

补充：**std::move()**函数会把变量强制转化成右值，多见于移动构造函数。

完美转发多用于模板，效果是让传递的参数是左值就判定为左值，是右值就判定为右值，否则传入右值有可能会被转化成左值

| 技术                  | 作用                           | 关键组件                |
| :-------------------- | :----------------------------- | :---------------------- |
| **通用引用（`T&&`）** | 同时匹配左值和右值             | 模板参数推导 + 引用折叠 |
| **`std::forward`**    | 按需返回左值/右值引用          | 条件转换，保持值类别    |
| **完美转发**          | 避免参数类型退化，支持移动语义 | 二者结合                |

**核心原则**：

- 用 `T&&` 接收参数（通用引用）。
- 用 `std::forward<T>` 转发参数。
- 确保模板参数 `T` 能正确推导出引用类型（如 `int&` 或 `int&&`）。

## 深拷贝与浅拷贝

深拷贝在拷贝对象时，如果被拷贝对象内部还有指针引用指向其他资源，自己需要重新开辟一块新内存存储资源，而不是简单的赋值

浅拷贝类似于引用，得到的只是对象的别名，修改新对象的值会改变原对象的值

## 多态

1.静态多态

方式：模板，重载，时间：编译时进行

2.动态多态

原理：虚函数，方式：重写，时间：运行时

## 虚函数

1.有virtual声明的虚函数的类在编译阶段，会生成一张虚函数表（vtable）

2. **派生类构造函数负责将vptr指向正确的vtable**（完成多态绑定），会继承基类的虚函数表结构，并用自己的实现替换重写的虚函数指针。当通过基类指针调用虚函数时，运行时通过对象的vptr定位到虚函数表，再通过表中存储的函数指针调用最终实现的函数。

   ✅ **vtable是编译器生成的静态数据**（编译期决定）

   ✅ **vptr是对象构造时初始化的动态指针**（运行时设置）

   ✅ **派生类构造函数负责将vptr指向正确的vtable**（完成多态绑定）

|    特性    |        C++         |
| :--------: | :----------------: |
|  生成时机  |       编译期       |
|  存储位置  | 可执行文件的数据段 |
| 是否可修改 | 只读（现代编译器） |

### 构造函数可以是虚函数吗？

不能，因为vptr要在构造函数调用时构造，如果构造函数是虚函数逻辑就相悖了，会报错

### 析构函数一定要是虚函数吗？

不一定，但建议设成虚函数，能够避免调用析构函数出错，导致内存泄漏的现象

## this指针的作用

## 可以使用delete this吗

## unordered_map扩容原理

## vector扩容原理

##  智能指针

智能指针都是基于RAII思想的，RAII 的核心是通过对象的生命周期管理资源（如内存、文件句柄等），确保资源在析构时被释放。

unique_ptr:一份资源只能被一个unique_ptr指着，无法被拷贝

（禁用了拷贝构造函数和拷贝构造等号运算符）

shared_ptr:引用计数是线程安全的（原子变量），引用计数减到0时释放资源。

weak_ptr:用来解决shared_ptr的循环引用问题

**shared_ptr的实现思路**：关键是要用原子变量的引用计数，一降到0就释放资源。

## 虚继承

用于解决菱形继承问题，使用方式是派生类继承基类时使用virtual关键字。

菱形继承问题：两个派生类同时继承一个基类，而有一个孙子派生类又同时继承了这俩个派生类，会导致构造的时候出现两个基类。

C++ 通过 **虚继承** 确保菱形继承中 **基类只被派生类共享一份**：

| 问题     | 原因                   | 解决方案                                     |
| :------- | :--------------------- | :------------------------------------------- |
| 数据冗余 | 多份基类子对象         | 虚继承（`virtual public Base`）              |
| 二义性   | 编译器无法确定访问路径 | 虚继承或显式指定路径（`obj.Derived1::data`） |
| 构造重复 | 基类被多次构造         | 虚继承后由最底层派生类构造基类               |

## 纯虚函数和抽象类

## static

1.声明局部变量：表示

2.类：类不需要实例也能访问，且只能被类内声明为static的访问

3.声明类中的函数：这个函数被所有实例共享

## const

## explicit

防止隐式类型转换

如shared_ptr中要用关键字explicit去声明一下构造函数，否则能够使用ptr = new .... 

## 四种类型转换

static_cast: 明确定义类型之间的转换

dynamic_cast:多态类型指针或引用的转换，基类到派生类的转换

const_cast:从常量转化为非常量

rein..:无关类型间的转换，如字符串到浮点数

## 六种内存序

memory_order_relaxed

memory_order_

memory

## volatile

看那个八股视频

# go

## GC的原理

1.三色

2.写屏障

## GMP

## map原理

## 切片扩容



# 操作系统

## 进程和线程的区别

- **进程（Process）**：
  - 操作系统 **资源分配的基本单位**（拥有独立的内存、文件句柄、CPU 时间片等）。
  - 每个进程至少包含 **1 个线程**（主线程）。
  - 进程间相互隔离，崩溃后不影响其他进程。
- **线程（Thread）**：
  - 操作系统 **调度的基本单位**（共享进程的资源，如内存、文件）。
  - 线程属于进程，一个进程可包含 **多个线程**。
  - 线程间共享数据，但需要同步机制（如锁）避免竞争。

| **对比维度**      | **进程**                      | **线程**                         |
| :---------------- | :---------------------------- | :------------------------------- |
| **资源占用**      | 独立内存空间，开销大          | 共享进程资源，开销小             |
| **切换成本**      | 高（需切换内存空间）          | 低（仅切换执行上下文）           |
| **通信方式**      | IPC（管道、信号、共享内存等） | 直接读写共享内存（需同步）       |
| **安全性**        | 隔离性强，崩溃不影响其他进程  | 一个线程崩溃可能导致整个进程退出 |
| **创建/销毁速度** | 慢                            | 快                               |
| **适用场景**      | 需要高稳定性、隔离性的任务    | 需要高并发、频繁交互的任务       |

## 进程间通信和线程间通信

1. 阻塞和非阻塞
2. 同步和异步

1. socket 的原理
2. 什么是死锁，怎么解决

# 计算机网络

## 网址从输入发生了什么？

## DNS是怎么将url解析成ip地址的

## http1.0，1.1，2.0，3.0之间的区别

## http和https的区别

## 讲一讲TLS握手的过程，RSA是怎么保证安全性的，讲一讲CA

## TCP三次握手四次挥手

## TCP的可靠性

# mysql

## 索引

## 回表

### 覆盖索引

### 索引下推

### 最左匹配

## innodb和myISAM的区别，优劣？

## MVCC（undo日志）

## WAL（redo日志）

## 常见的数据库优化方式

# redis

## redis为什么这么快

1.基于内存----DRAM比SRAM快很多！

2.单线程----没有线程切换和上锁的开销

（某个版本之后，网络IO是多线程的）

3.高效的数据结构

五种基本数据结构：1.hash 2.list 3.Zset 4.set 5.

三种特殊的：bitmap（布隆过滤器），GEO（地理信息，附近的人），

## 缓存一致性

## 哨兵模式

## 分布式锁

## 红锁

主节点在同步从节点的时候挂掉了，导致锁没同步上怎么办？

使用红锁，只有当半数节点（自己能调）都上了锁之后才认为锁成功了

## 看门狗

防止锁过期，开一个线程专门用来监视锁的时间，例如锁的持续时间是30s，则这个线程会每过10s确定节点还活着，并延长锁的时间为30s

# 设计模式

## 单例模式

单例模式适用于一个程序运行周期中只能初始化一次的实例（线程池，数据库连接池，日志）。分为饿汉式（程序编译时就初始化）和懒汉式（运行时调用函数初始化）。

懒汉式实现方式：getInstance()中用static构造实例，确保多次调用也只初始化一次

| 方式                                  | 线程安全 | 初始化时机   | 性能           | 推荐度              |
| :------------------------------------ | :------- | :----------- | :------------- | :------------------ |
| **饿汉式**                            | ✅ 安全   | 程序启动时   | ⚡ 无锁开销     | ⭐⭐（适合简单场景）  |
| **懒汉式（加锁）**                    | ✅ 安全   | 第一次访问时 | 🔒 每次访问加锁 | ⭐（性能差）         |
| **双重检查锁定（DCLP）**              | ✅ 安全   | 第一次访问时 | ⚡ 仅第一次加锁 | ⭐⭐⭐（C++11 前适用） |
| **Meyer's Singleton（局部静态变量）** | ✅ 安全   | 第一次访问时 | ⚡ 无锁开销     | ⭐⭐⭐⭐⭐（最佳实践）   |

## 工厂模式 & 抽象工厂模式

## 观察者

## 状态机

## 建造者

## 策略

## 里氏开闭

对扩展开放，对修改关闭

## 迪米特

# 消息队列

## kafka

## rabbitMQ

# 云原生相关
# C++

## C++中值传递和引用传递的区别

1.一个拷贝一个不拷贝

2.一个可以在函数中修改值，一个不能

常引用：省去拷贝的同时，保证了变量的安全性（值无法被修改）

## C与C++的区别

1.面向对象与面向对象的三大特性（封装继承多态）

2.内存管理（new，delete，智能指针）

3.STL标准库

4.模板

## 左值和右值的区别

左值：可以取地址的值

右值：常量，临时变量等不能取地址的值

应用：移动语义

## 什么是移动语义和完美转发

一种优化资源管理的机制，常规的资源管理是拷贝别人的资源，而移动语义是转移所有权，转移了资源而不是拷贝资源，性能会更好。

补充：**std::move()**函数会把变量强制转化成右值，多见于移动构造函数。

完美转发多用于模板，效果是让传递的参数是左值就判定为左值，是右值就判定为右值，否则传入右值有可能会被转化成左值

| 技术                  | 作用                           | 关键组件                |
| :-------------------- | :----------------------------- | :---------------------- |
| **通用引用（`T&&`）** | 同时匹配左值和右值             | 模板参数推导 + 引用折叠 |
| **`std::forward`**    | 按需返回左值/右值引用          | 条件转换，保持值类别    |
| **完美转发**          | 避免参数类型退化，支持移动语义 | 二者结合                |

**核心原则**：

- 用 `T&&` 接收参数（通用引用）。
- 用 `std::forward<T>` 转发参数。
- 确保模板参数 `T` 能正确推导出引用类型（如 `int&` 或 `int&&`）。

## 深拷贝与浅拷贝

深拷贝在拷贝对象时，如果被拷贝对象内部还有指针引用指向其他资源，自己需要重新开辟一块新内存存储资源，而不是简单的赋值

浅拷贝类似于引用，得到的只是对象的别名，修改新对象的值会改变原对象的值

## 多态

1.静态多态

方式：模板，重载，时间：编译时进行

2.动态多态

原理：虚函数，方式：重写，时间：运行时

## 虚函数

1.有virtual声明的虚函数的类在编译阶段，会生成一张虚函数表（vtable）

2. **派生类构造函数负责将vptr指向正确的vtable**（完成多态绑定），会继承基类的虚函数表结构，并用自己的实现替换重写的虚函数指针。当通过基类指针调用虚函数时，运行时通过对象的vptr定位到虚函数表，再通过表中存储的函数指针调用最终实现的函数。

   ✅ **vtable是编译器生成的静态数据**（编译期决定）

   ✅ **vptr是对象构造时初始化的动态指针**（运行时设置）

   ✅ **派生类构造函数负责将vptr指向正确的vtable**（完成多态绑定）

|    特性    |        C++         |
| :--------: | :----------------: |
|  生成时机  |       编译期       |
|  存储位置  | 可执行文件的数据段 |
| 是否可修改 | 只读（现代编译器） |

### *构造函数可以是虚函数吗？

不能，因为vptr要在构造函数调用时构造，如果构造函数是虚函数逻辑就相悖了，会报错

### 析构函数一定要是虚函数吗？

不一定，但建议设成虚函数，能够避免调用析构函数出错，导致内存泄漏的现象。

如果不设成虚函数，派生类默认的是调用基类的析构函数，可能会导致资源未释放或重复释放。

## this指针的作用

## 可以使用delete this吗

## unordered_map扩容原理

## vector扩容原理

##  智能指针

智能指针都是基于RAII思想的，RAII 的核心是通过对象的生命周期管理资源（如内存、文件句柄等），确保资源在析构时被释放。

unique_ptr:一份资源只能被一个unique_ptr指着，无法被拷贝

（禁用了拷贝构造函数和拷贝构造等号运算符）

shared_ptr:引用计数是线程安全的（原子变量），引用计数减到0时释放资源。

weak_ptr:用来解决shared_ptr的循环引用问题

**shared_ptr的实现思路**：关键是要用原子变量的引用计数，一降到0就释放资源。

## 虚继承

用于解决菱形继承问题，使用方式是派生类继承基类时使用virtual关键字。

菱形继承问题：两个派生类同时继承一个基类，而有一个孙子派生类又同时继承了这俩个派生类，会导致构造的时候出现两个基类。

C++ 通过 **虚继承** 确保菱形继承中 **基类只被派生类共享一份**：

| 问题     | 原因                   | 解决方案                                     |
| :------- | :--------------------- | :------------------------------------------- |
| 数据冗余 | 多份基类子对象         | 虚继承（`virtual public Base`）              |
| 二义性   | 编译器无法确定访问路径 | 虚继承或显式指定路径（`obj.Derived1::data`） |
| 构造重复 | 基类被多次构造         | 虚继承后由最底层派生类构造基类               |

## 纯虚函数和抽象类

## static

1.声明局部变量：表示

2.类：类不需要实例也能访问，且只能被类内声明为static的访问

3.声明类中的函数：这个函数被所有实例共享

（多用于实现单例）

## const

## explicit

防止隐式类型转换

如shared_ptr中要用关键字explicit去声明一下构造函数，否则能够使用ptr = new .... 

## 四种类型转换

static_cast: 明确定义类型之间的转换

dynamic_cast:多态类型指针或引用的转换，基类到派生类的转换

const_cast:从常量转化为非常量

rein..:无关类型间的转换，如字符串到浮点数

## 六种内存序

memory_order_relaxed

memory_order_

memory

## volatile

主要用于实现原子变量（不让编译器做优化）

让编译器不要把存在寄存器，而是放在内存中，避免数据竞争

## 阻止继承的方法

1.final（c++11）

2.构造函数私有化

# go

## GC的原理

1.三色标记法

黑白灰

先把所有标记为灰

2.写屏障

## GMP

G:

## map底层

哈希表，拉链法，超过负载因子触发扩容（增量扩容，等量扩容）

## slice底层

底层是一个数组，slice实际上是一个结构体，字段是capacity, len

切片实际上截取了底层数组的一部分，如果触发扩容会先拷贝，在拷贝上面修改

## 切片，map扩容

## 讲讲线程与协程的区别

## 讲讲go协程，goroutine，channel

## context

## 往一个channel中大量读写会发生什么

# 操作系统

## 进程和线程的区别

- **进程（Process）**：
  - 操作系统 **资源分配的基本单位**（拥有独立的内存、文件句柄、CPU 时间片等）。
  - 每个进程至少包含 **1 个线程**（主线程）。
  - 进程间相互隔离，崩溃后不影响其他进程。
- **线程（Thread）**：
  - 操作系统 **调度的基本单位**（共享进程的资源，如内存、文件）。
  - 线程属于进程，一个进程可包含 **多个线程**。
  - 线程间共享数据，但需要同步机制（如锁）避免竞争。

| **对比维度**      | **进程**                      | **线程**                         |
| :---------------- | :---------------------------- | :------------------------------- |
| **资源占用**      | 独立内存空间，开销大          | 共享进程资源，开销小             |
| **切换成本**      | 高（需切换内存空间）          | 低（仅切换执行上下文）           |
| **通信方式**      | IPC（管道、信号、共享内存等） | 直接读写共享内存（需同步）       |
| **安全性**        | 隔离性强，崩溃不影响其他进程  | 一个线程崩溃可能导致整个进程退出 |
| **创建/销毁速度** | 慢                            | 快                               |
| **适用场景**      | 需要高稳定性、隔离性的任务    | 需要高并发、频繁交互的任务       |

## 进程间通信和线程间通信

1. 阻塞和非阻塞
2. 同步和异步

3. socket 的原理
4. 什么是死锁，怎么解决

## 零拷贝

## 阻塞IO/非阻塞IO/同步IO/异步IO

## 软链接硬链接

硬链接类似于文件的别名，只有当所有硬链接都删除掉，才会释放掉文件资源

软链接类似于windows的文件快捷方式

inode在其中发挥了什么作用？

在文件系统中，`inode`（索引节点）是理解硬链接和软链接（符号链接）如何工作的关键。以下是它在两者中的作用：

------

### **1. 硬链接（Hard Link）与 inode**

- **本质**：硬链接是同一个文件的多个名称（别名），**共享同一个 inode**。

- **inode 的作用**：

  - 每个文件（包括硬链接）对应一个唯一的 inode，inode 存储文件的元数据（权限、所有者、磁盘块位置等），**但不包含文件名**。
  - 硬链接直接指向原始文件的 inode，因此**所有硬链接和原始文件在文件系统中是平等的**（没有主次之分）。
  - inode 中有一个计数器（`link count`），记录指向它的硬链接数量。只有当该计数器归零（即所有硬链接被删除）时，文件系统才会释放磁盘空间。

  plaintext

  复制

  ```plaintext
  文件A（名字） → inode#123 → 数据块
  文件B（硬链接） ↗
  （文件A和B共享 inode#123，link count=2）
  ```

- **特点**：

  - 硬链接不能跨文件系统（因为不同文件系统的 inode 独立）。
  - 删除任意一个硬链接（包括原始文件）不会影响其他链接，直到 link count=0。

------

### **2. 软链接（Symbolic Link，Soft Link）与 inode**

- **本质**：软链接是一个独立的文件，**拥有自己的 inode**，但内容指向另一个文件的路径（类似于快捷方式）。

- **inode 的作用**：

  - 软链接的 inode 存储的是**目标文件的路径字符串**，而不是目标文件的 inode。
  - 当访问软链接时，系统会通过路径重定向到目标文件的 inode，再访问其数据。

  plaintext

  复制

  ```plaintext
  软链接文件 → inode#456 → 内容为"path/to/目标文件"
  目标文件 → inode#123 → 数据块
  （软链接和目标文件的 inode 不同）
  ```

- **特点**：

  - 可以跨文件系统（因为依赖路径而非 inode）。
  - 如果目标文件被删除，软链接会变成“悬空链接”（Dangling link），指向无效路径。

------

### **关键区别总结**

| **特性**       | **硬链接**                       | **软链接**       |
| -------------- | -------------------------------- | ---------------- |
| **inode**      | 共享目标文件的 inode             | 拥有独立的 inode |
| **跨文件系统** | 不支持                           | 支持             |
| **依赖目标**   | 直接依赖 inode                   | 依赖路径字符串   |
| **删除目标**   | 不影响其他硬链接（link count-1） | 导致软链接失效   |

------

### **示例命令观察 inode**

```bash
# 创建文件、硬链接和软链接
echo "test" > file.txt
ln file.txt hardlink      # 硬链接
ln -s file.txt softlink   # 软链接

# 查看 inode 和链接计数
ls -li
# 输出示例：
# 123456 -rw-r--r-- 2 user group 5 Jan 1 10:00 file.txt
# 123456 -rw-r--r-- 2 user group 5 Jan 1 10:00 hardlink
# 789012 lrwxrwxrwx 1 user group 8 Jan 1 10:00 softlink -> file.txt
```

- `file.txt` 和 `hardlink` 的 inode 相同（`123456`），且 link count=2。
- `softlink` 的 inode 不同（`789012`），且标记为符号链接（`l`）。

通过理解 inode 的作用，可以更清晰地掌握硬链接和软链接的行为差异。

# 计算机网络

## 网址从输入发生了什么？

## DNS是怎么将url解析成ip地址的

## http1.0，1.1，2.0，3.0之间的区别

## http和https的区别

## http状态码，报文

## 讲一讲TLS握手的过程，RSA是怎么保证安全性的，讲一讲CA

## TCP三次握手四次挥手

## TCP的可靠性

![image-20250422182900799](C:\Users\66494\AppData\Roaming\Typora\typora-user-images\image-20250422182900799.png)

## TCP报文，udp报文

# mysql

## 索引

## 回表

### 覆盖索引

### 索引下推

### 最左匹配

## innodb和myISAM的区别，优劣？

## MVCC（undo日志）

## WAL（redo日志）

## binlog

## 常见的数据库优化方式

# redis

## redis为什么这么快

1.基于内存: DRAM比SRAM快很多！

2.单线程: 没有线程切换和上锁的开销

（某个版本之后，网络IO是多线程的）

3.高效的数据结构

五种基本数据结构：1.hash 2.list 3.Zset（SSort） 4.set 5.

三种特殊的：bitmap（布隆过滤器），GEO（地理信息，附近的人，附近店铺），

### 删除策略

1.懒删除

2.定期删除

有个随机抽样是啥来着

### 内存淘汰策略



## 缓存一致性

![1f0d6cd861f92ab72e95e07f8225b90b](C:\Users\66494\Documents\Tencent Files\664945264\nt_qq\nt_data\Pic\2025-04\Ori\1f0d6cd861f92ab72e95e07f8225b90b.png)

## 哨兵模式

## 分布式锁

## 红锁

主节点在同步从节点的时候挂掉了，导致锁没同步上怎么办？

使用红锁，只有当半数节点（自己能调）都上了锁之后才认为锁成功了

## 看门狗

防止锁过期，开一个线程专门用来监视锁的时间，例如锁的持续时间是30s，则这个线程会每过10s确定节点还活着，并延长锁的时间为30s

## 内存数据结构

1.list

2.hash

3.set

4.Zset(Sorted Set)

5.string(SDS)

# 设计模式

## 依赖注入控制倒转

kratos用wire实现依赖注入

## 单例模式

单例模式适用于一个程序运行周期中只能初始化一次的实例（线程池，数据库连接池，日志）。分为饿汉式（程序编译时就初始化）和懒汉式（运行时调用函数初始化）。

懒汉式实现方式：getInstance()中用static构造实例，确保多次调用也只初始化一次，放在private里面

| 方式                                  | 线程安全 | 初始化时机   | 性能           | 推荐度              |
| :------------------------------------ | :------- | :----------- | :------------- | :------------------ |
| **饿汉式**                            | ✅ 安全   | 程序启动时   | ⚡ 无锁开销     | ⭐⭐（适合简单场景）  |
| **懒汉式（加锁）**                    | ✅ 安全   | 第一次访问时 | 🔒 每次访问加锁 | ⭐（性能差）         |
| **双重检查锁定（DCLP）**              | ✅ 安全   | 第一次访问时 | ⚡ 仅第一次加锁 | ⭐⭐⭐（C++11 前适用） |
| **Meyer's Singleton（局部静态变量）** | ✅ 安全   | 第一次访问时 | ⚡ 无锁开销     | ⭐⭐⭐⭐⭐（最佳实践）   |

## 工厂模式 & 抽象工厂模式

## 观察者

## 状态机

## 建造者

## 策略

策略模式（Strategy Pattern）是一种行为设计模式，它允许你定义一系列的算法，把它们一个个封装起来，并使它们可以相互替换。策略模式让算法的变化独立于使用算法的客户。这种类型属于行为型模式。

假设我们有一个简单的排序任务，我们可以使用不同的排序算法（如冒泡排序、选择排序、快速排序等）作为策略。

## 里氏开闭

对扩展开放，对修改关闭

## 迪米特

# 消息队列

## kafka

## rabbitMQ

## rocketMQ

# 微服务，分布式，负载均衡，云原生

## k8s

## docker

## istio

### 讲讲ABA问题

CAS判断时

### 关于rpc
