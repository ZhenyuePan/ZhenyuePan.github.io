---
title: "4.16实习八股整理"
publishedAt: "2025-4-16"
summary: "主要包括C++，操作系统，计算机网络，redis，mysql"
---

# C++

## C++中值传递和引用传递的区别

1.一个拷贝一个不拷贝

2.一个可以在函数中修改值，一个不能

常引用：省去拷贝的同时，保证了变量的安全性（值无法被修改）

## C与C++的区别

1.面向对象与面向对象的三大特性（封装继承多态）

2.内存管理（new，delete，智能指针）

3.STL标准库

4.模板

## 左值和右值的区别

左值：可以取地址的值

右值：常量，临时变量等不能取地址的值

应用：移动语义

## 什么是移动语义和完美转发

一种优化资源管理的机制，常规的资源管理是拷贝别人的资源，而移动语义是转移所有权，转移了资源而不是拷贝资源，性能会更好。

补充：**std::move()**函数会把变量强制转化成右值，多见于移动构造函数。

完美转发多用于模板，效果是让传递的参数是左值就判定为左值，是右值就判定为右值，否则传入右值有可能会被转化成左值

| 技术                  | 作用                           | 关键组件                |
| :-------------------- | :----------------------------- | :---------------------- |
| **通用引用（`T&&`）** | 同时匹配左值和右值             | 模板参数推导 + 引用折叠 |
| **`std::forward`**    | 按需返回左值/右值引用          | 条件转换，保持值类别    |
| **完美转发**          | 避免参数类型退化，支持移动语义 | 二者结合                |

**核心原则**：

- 用 `T&&` 接收参数（通用引用）。
- 用 `std::forward<T>` 转发参数。
- 确保模板参数 `T` 能正确推导出引用类型（如 `int&` 或 `int&&`）。

## 深拷贝与浅拷贝

深拷贝在拷贝对象时，如果被拷贝对象内部还有指针引用指向其他资源，自己需要重新开辟一块新内存存储资源，而不是简单的赋值

浅拷贝类似于引用，得到的只是对象的别名，修改新对象的值会改变原对象的值

## 多态

1.静态多态

方式：模板，重载，时间：编译时进行

2.动态多态

原理：虚函数，方式：重写，时间：运行时

## 虚函数

1.有virtual声明的虚函数的类在编译阶段，会生成一张虚函数表（vtable）

2. **派生类构造函数负责将vptr指向正确的vtable**（完成多态绑定），会继承基类的虚函数表结构，并用自己的实现替换重写的虚函数指针。当通过基类指针调用虚函数时，运行时通过对象的vptr定位到虚函数表，再通过表中存储的函数指针调用最终实现的函数。

   ✅ **vtable是编译器生成的静态数据**（编译期决定）

   ✅ **vptr是对象构造时初始化的动态指针**（运行时设置）

   ✅ **派生类构造函数负责将vptr指向正确的vtable**（完成多态绑定）

|    特性    |        C++         |
| :--------: | :----------------: |
|  生成时机  |       编译期       |
|  存储位置  | 可执行文件的数据段 |
| 是否可修改 | 只读（现代编译器） |

### 构造函数可以是虚函数吗？

不能，因为vptr要在构造函数调用时构造，如果构造函数是虚函数逻辑就相悖了，会报错

### 析构函数一定要是虚函数吗？

不一定，但建议设成虚函数，能够避免调用析构函数出错，导致内存泄漏的现象

## this指针的作用

## 可以使用delete this吗

## unordered_map扩容原理

## vector扩容原理

##  智能指针

智能指针都是基于RAII思想的，RAII 的核心是通过对象的生命周期管理资源（如内存、文件句柄等），确保资源在析构时被释放。

unique_ptr:一份资源只能被一个unique_ptr指着，无法被拷贝

（禁用了拷贝构造函数和拷贝构造等号运算符）

shared_ptr:引用计数是线程安全的（原子变量），引用计数减到0时释放资源。

weak_ptr:用来解决shared_ptr的循环引用问题

**shared_ptr的实现思路**：关键是要用原子变量的引用计数，一降到0就释放资源。

## 虚继承

用于解决菱形继承问题，使用方式是派生类继承基类时使用virtual关键字。

菱形继承问题：两个派生类同时继承一个基类，而有一个孙子派生类又同时继承了这俩个派生类，会导致构造的时候出现两个基类。

C++ 通过 **虚继承** 确保菱形继承中 **基类只被派生类共享一份**：

| 问题     | 原因                   | 解决方案                                     |
| :------- | :--------------------- | :------------------------------------------- |
| 数据冗余 | 多份基类子对象         | 虚继承（`virtual public Base`）              |
| 二义性   | 编译器无法确定访问路径 | 虚继承或显式指定路径（`obj.Derived1::data`） |
| 构造重复 | 基类被多次构造         | 虚继承后由最底层派生类构造基类               |

## 纯虚函数和抽象类

## static

1.声明局部变量：表示

2.类：类不需要实例也能访问，且只能被类内声明为static的访问

3.声明类中的函数：这个函数被所有实例共享

## const

## explicit

防止隐式类型转换

如shared_ptr中要用关键字explicit去声明一下构造函数，否则能够使用ptr = new .... 

## 四种类型转换

static_cast: 明确定义类型之间的转换

dynamic_cast:多态类型指针或引用的转换，基类到派生类的转换

const_cast:从常量转化为非常量

rein..:无关类型间的转换，如字符串到浮点数

## 六种内存序

memory_order_relaxed

memory_order_

memory

## volatile

看那个八股视频

# go

## GC的原理

1.三色

2.写屏障

## GMP

## map原理

## 切片扩容



# 操作系统

## 进程和线程的区别

- **进程（Process）**：
  - 操作系统 **资源分配的基本单位**（拥有独立的内存、文件句柄、CPU 时间片等）。
  - 每个进程至少包含 **1 个线程**（主线程）。
  - 进程间相互隔离，崩溃后不影响其他进程。
- **线程（Thread）**：
  - 操作系统 **调度的基本单位**（共享进程的资源，如内存、文件）。
  - 线程属于进程，一个进程可包含 **多个线程**。
  - 线程间共享数据，但需要同步机制（如锁）避免竞争。

| **对比维度**      | **进程**                      | **线程**                         |
| :---------------- | :---------------------------- | :------------------------------- |
| **资源占用**      | 独立内存空间，开销大          | 共享进程资源，开销小             |
| **切换成本**      | 高（需切换内存空间）          | 低（仅切换执行上下文）           |
| **通信方式**      | IPC（管道、信号、共享内存等） | 直接读写共享内存（需同步）       |
| **安全性**        | 隔离性强，崩溃不影响其他进程  | 一个线程崩溃可能导致整个进程退出 |
| **创建/销毁速度** | 慢                            | 快                               |
| **适用场景**      | 需要高稳定性、隔离性的任务    | 需要高并发、频繁交互的任务       |

## 进程间通信和线程间通信

1. 阻塞和非阻塞
2. 同步和异步

1. socket 的原理
2. 什么是死锁，怎么解决

# 计算机网络

## 网址从输入发生了什么？

## DNS是怎么将url解析成ip地址的

## http1.0，1.1，2.0，3.0之间的区别

## http和https的区别

## 讲一讲TLS握手的过程，RSA是怎么保证安全性的，讲一讲CA

## TCP三次握手四次挥手

## TCP的可靠性

# mysql

## 索引

## 回表

### 覆盖索引

### 索引下推

### 最左匹配

## innodb和myISAM的区别，优劣？

## MVCC（undo日志）

## WAL（redo日志）

## 常见的数据库优化方式

# redis

## redis为什么这么快

1.基于内存----DRAM比SRAM快很多！

2.单线程----没有线程切换和上锁的开销

（某个版本之后，网络IO是多线程的）

3.高效的数据结构

五种基本数据结构：1.hash 2.list 3.Zset 4.set 5.

三种特殊的：bitmap（布隆过滤器），GEO（地理信息，附近的人），

## 缓存一致性

## 哨兵模式

## 分布式锁

## 红锁

主节点在同步从节点的时候挂掉了，导致锁没同步上怎么办？

使用红锁，只有当半数节点（自己能调）都上了锁之后才认为锁成功了

## 看门狗

防止锁过期，开一个线程专门用来监视锁的时间，例如锁的持续时间是30s，则这个线程会每过10s确定节点还活着，并延长锁的时间为30s

# 设计模式

## 单例模式

单例模式适用于一个程序运行周期中只能初始化一次的实例（线程池，数据库连接池，日志）。分为饿汉式（程序编译时就初始化）和懒汉式（运行时调用函数初始化）。

懒汉式实现方式：getInstance()中用static构造实例，确保多次调用也只初始化一次

| 方式                                  | 线程安全 | 初始化时机   | 性能           | 推荐度              |
| :------------------------------------ | :------- | :----------- | :------------- | :------------------ |
| **饿汉式**                            | ✅ 安全   | 程序启动时   | ⚡ 无锁开销     | ⭐⭐（适合简单场景）  |
| **懒汉式（加锁）**                    | ✅ 安全   | 第一次访问时 | 🔒 每次访问加锁 | ⭐（性能差）         |
| **双重检查锁定（DCLP）**              | ✅ 安全   | 第一次访问时 | ⚡ 仅第一次加锁 | ⭐⭐⭐（C++11 前适用） |
| **Meyer's Singleton（局部静态变量）** | ✅ 安全   | 第一次访问时 | ⚡ 无锁开销     | ⭐⭐⭐⭐⭐（最佳实践）   |

## 工厂模式 & 抽象工厂模式

## 观察者

## 状态机

## 建造者

## 策略

## 里氏开闭

对扩展开放，对修改关闭

## 迪米特

# 消息队列

## kafka

## rabbitMQ

# 云原生相关

